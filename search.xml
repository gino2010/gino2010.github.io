<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Career Review]]></title>
    <url>%2F2021%2F10%2F31%2Fcareer-review%2F</url>
    <content type="text"><![CDATA[简单记录一下这两天的思考，快写快结束，时间有限任务多。 从业那么多年，我都掌握了什么？感觉做了很多，但深入的很少。都说技术人员年龄大了需要转行，我反而没有这个打算，更期待像海外开发者那样可以一直做下去。当然需要做的越来越好 最近开始刷leetCode，作为程序员还是有必要刷一下的。至少给我带来很多思考，例如代码性能细节还有基本算法实现。这个会坚持做下去，让自己更为专业 除了Spring还有很多框架值得使用，最近也是看了一个海外程序员的采访让我有所了解，加之后面项目会脱离spring体系正好学习和改变一下 Python的练习并没有停止过，包括在leetCode中，我也是Java 和 Python 两种代码同时书写。因为Python还是很好的工具，坚信今后一定会用到的，必须提前积累 系统架构和设计，或多或少还是知道的，但应该找个时间整理一下，形成一个完整的知识体系和自用的评判逻辑，便于今后快速使用 所在行业的业务知识需要继续不断提升，职场英语也是。至少现在目标很明确，比之前学习速度提高了不少 其实本质想法很简单，我想把工作做到”专业”，自身价值得以体现，可以不停的发展下去。 人有时会自己迷失自己，会浪费很多精力（精神内耗）和时间。现在个人事情也是越来越多，合理处理事情–明确思路选对工具–很重要。 另一个思考：最近的Macbook Pro 性能真的是炸天，价格也是贵的史无前例，中高配都已经赶上了当年的Mac Pro价格。但从个人实际使用角度出发，其实低配的Macbook Pro足以满足我的需求。所以理性对待，找到更适合自己的才更关键，而不是一味的的追求最好的。 简单说这是一个普通人应该学会的”克制”。 我穷故我思😄]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Guice]]></title>
    <url>%2F2021%2F10%2F23%2Fgoogle-guice%2F</url>
    <content type="text"><![CDATA[除了Spring，你还知道其它依赖注入框架吗？今天我看到了 Google Guice。其实早在2009年它就在Google I/O大会上被介绍过，我现在才知道。是时候放下Spring了，了解一些其它”主流”框架了。原因是：Spring 是强大的，但你真的需要那么强大的它吗？ 先翻译一下Motivation这个文章，来感受一下Google Guice 动机将所有内容连接在一起是应用程序开发的乏味部分。 有几种方法可以将数据、服务和表示类相互连接起来。 为了对比这些方法，我们将为披萨订购网站编写计费代码： 123456789101112public interface BillingService &#123; /** * Attempts to charge the order to the credit card. Both successful and * failed transactions will be recorded. * * @return a receipt of the transaction. If the charge was successful, the * receipt will be successful. Otherwise, the receipt will contain a * decline note describing why the charge failed. */ Receipt chargeOrder(PizzaOrder order, CreditCard creditCard);&#125; 随着实现，我们将为我们的代码编写单元测试。 在测试中，我们需要一个 FakeCreditCardProcessor 来避免向真正的信用卡收费！ 直接构造函数调用当我们刚刚更新信用卡处理器和交易记录器时，代码如下所示： 123456789101112131415161718public class RealBillingService implements BillingService &#123; public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) &#123; CreditCardProcessor processor = new PaypalCreditCardProcessor(); TransactionLog transactionLog = new DatabaseTransactionLog(); try &#123; ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); &#125; catch (UnreachableException e) &#123; transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); &#125; &#125;&#125; 这段代码给模块化和可测试性带来了问题。 对真实信用卡处理器的直接编译时依赖意味着测试代码将收取信用卡费用！ 测试拒绝收费或服务不可用时会发生什么也很尴尬。 工厂模式工厂类将客户端和实现类解耦。 一个简单的工厂使用静态方法来获取和设置接口的模拟实现。 工厂是用一些样板代码实现的： 12345678910111213141516public class CreditCardProcessorFactory &#123; private static CreditCardProcessor instance; public static void setInstance(CreditCardProcessor processor) &#123; instance = processor; &#125; public static CreditCardProcessor getInstance() &#123; if (instance == null) &#123; return new SquareCreditCardProcessor(); &#125; return instance; &#125;&#125; 在我们的客户端代码中，我们用工厂查找替换new调用： 123456789101112131415161718public class RealBillingService implements BillingService &#123; public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) &#123; CreditCardProcessor processor = CreditCardProcessorFactory.getInstance(); TransactionLog transactionLog = TransactionLogFactory.getInstance(); try &#123; ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); &#125; catch (UnreachableException e) &#123; transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); &#125; &#125;&#125; 工厂模式可以编写正确的单元测试： 1234567891011121314151617181920212223242526272829public class RealBillingServiceTest extends TestCase &#123; private final PizzaOrder order = new PizzaOrder(100); private final CreditCard creditCard = new CreditCard("1234", 11, 2010); private final InMemoryTransactionLog transactionLog = new InMemoryTransactionLog(); private final FakeCreditCardProcessor processor = new FakeCreditCardProcessor(); @Override public void setUp() &#123; TransactionLogFactory.setInstance(transactionLog); CreditCardProcessorFactory.setInstance(processor); &#125; @Override public void tearDown() &#123; TransactionLogFactory.setInstance(null); CreditCardProcessorFactory.setInstance(null); &#125; public void testSuccessfulCharge() &#123; RealBillingService billingService = new RealBillingService(); Receipt receipt = billingService.chargeOrder(order, creditCard); assertTrue(receipt.hasSuccessfulCharge()); assertEquals(100, receipt.getAmountOfCharge()); assertEquals(creditCard, processor.getCardOfOnlyCharge()); assertEquals(100, processor.getAmountOfOnlyCharge()); assertTrue(transactionLog.wasSuccessLogged()); &#125;&#125; 这段代码很笨拙。 一个全局变量保存模拟实现，所以我们需要小心设置和拆除它。 如果tearDown 失败，全局变量将继续指向我们的测试实例。 这可能会导致其他测试出现问题。 它还阻止我们并行运行多个测试。 但最大的问题是依赖项隐藏在代码中。 如果我们添加对 CreditCardFraudTracker 的依赖，我们必须重新运行测试以找出哪些会中断。 如果我们忘记为生产服务初始化工厂，我们在尝试收费之前不会发现。 随着应用程序的增长，保姆工厂对生产力的消耗越来越大。 质量问题将被 QA 或验收测试发现。 这可能就足够了，但我们当然可以做得更好。 依赖注入和工厂一样，依赖注入只是一种设计模式。 核心原则是将行为与依赖解析分开。 在我们的示例中，RealBillingService 不负责查找 TransactionLog 和 CreditCardProcessor。 相反，它们作为构造函数参数传入： 123456789101112131415161718192021222324public class RealBillingService implements BillingService &#123; private final CreditCardProcessor processor; private final TransactionLog transactionLog; public RealBillingService(CreditCardProcessor processor, TransactionLog transactionLog) &#123; this.processor = processor; this.transactionLog = transactionLog; &#125; public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) &#123; try &#123; ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); &#125; catch (UnreachableException e) &#123; transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); &#125; &#125;&#125; 我们不需要任何工厂，我们可以通过删除 setUp 和 tearDown 样板来简化测试用例： 1234567891011121314151617181920public class RealBillingServiceTest extends TestCase &#123; private final PizzaOrder order = new PizzaOrder(100); private final CreditCard creditCard = new CreditCard("1234", 11, 2010); private final InMemoryTransactionLog transactionLog = new InMemoryTransactionLog(); private final FakeCreditCardProcessor processor = new FakeCreditCardProcessor(); public void testSuccessfulCharge() &#123; RealBillingService billingService = new RealBillingService(processor, transactionLog); Receipt receipt = billingService.chargeOrder(order, creditCard); assertTrue(receipt.hasSuccessfulCharge()); assertEquals(100, receipt.getAmountOfCharge()); assertEquals(creditCard, processor.getCardOfOnlyCharge()); assertEquals(100, processor.getAmountOfOnlyCharge()); assertTrue(transactionLog.wasSuccessLogged()); &#125;&#125; 现在，每当我们添加或删除依赖项时，编译器都会提醒我们需要修复哪些测试。 依赖项在 API 签名中公开。 不幸的是，现在 BillingService 的客户端需要查找其依赖项。 我们可以通过再次应用该模式来修复其中的一些问题！ 依赖它的类可以在其构造函数中接受 BillingService。 对于顶级类，有一个框架很有用。 否则，当您需要使用服务时，您将需要递归构建依赖项： 1234567public static void main(String[] args) &#123; CreditCardProcessor processor = new PaypalCreditCardProcessor(); TransactionLog transactionLog = new DatabaseTransactionLog(); BillingService billingService = new RealBillingService(processor, transactionLog); ... &#125; Guice 依赖注入依赖注入模式导致代码模块化和可测试，Guice 使其易于编写。 要在我们的计费示例中使用 Guice，我们首先需要告诉它如何将我们的接口映射到它们的实现。 此配置在 Guice 模块中完成，该模块是任何实现 Module 接口的 Java 类： 12345678public class BillingModule extends AbstractModule &#123; @Override protected void configure() &#123; bind(TransactionLog.class).to(DatabaseTransactionLog.class); bind(CreditCardProcessor.class).to(PaypalCreditCardProcessor.class); bind(BillingService.class).to(RealBillingService.class); &#125;&#125; 我们将@Inject 添加到 RealBillingService 的构造函数中，指示 Guice 使用它。 Guice 将检查带注释的构造函数，并查找每个参数的值。 12345678910111213141516171819202122232425public class RealBillingService implements BillingService &#123; private final CreditCardProcessor processor; private final TransactionLog transactionLog; @Inject public RealBillingService(CreditCardProcessor processor, TransactionLog transactionLog) &#123; this.processor = processor; this.transactionLog = transactionLog; &#125; public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) &#123; try &#123; ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); &#125; catch (UnreachableException e) &#123; transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); &#125; &#125;&#125; 最后，我们可以把它们放在一起。 Injector 可用于获取任何绑定类的实例。 12345public static void main(String[] args) &#123; Injector injector = Guice.createInjector(new BillingModule()); BillingService billingService = injector.getInstance(BillingService.class); ... &#125; 总结 Guice 是一个轻量级框架，实现依赖注入。（稍后深入其它特性） AbstractModule configure中的绑定，相当于Spring @component 等相关注解，Spring scan时即建立绑定关系。至于Guice何时对象初始化，我需要再看看。 @Inject 相当于 Spring 中的@Autowired，自动注入对象实例 最后一个UnitTest代码没有再提出，但可以想像就是之前的UniTest即可，在具体测试单元通过构造方法传参即可。或将整个UnitTest的AbstractModule配置修改，绑定对应的mock class。 初步感觉这个框架还是容易理解的，稍后深入后续内容。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Guice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thought Roaming]]></title>
    <url>%2F2021%2F10%2F09%2Fthought-roaming%2F</url>
    <content type="text"><![CDATA[今天在看书时脑袋有点开小差儿，开始天马行空起来。记录下来，也许今后可以review一下。 几日前，我和朋友聊天时突发一个想法。在阅读了部分金融知识后，我有种错觉，金融市场本身好像是一个”假说”，是人造之物必有缺陷之处。通过多年的积累，金融市场形成了”完（fu）善（za）”的交易规则和庞大的交易网络。他的作用是什么？使资本流动更加顺滑，促进人类文明发展？ 那如何衡量为人类文明的发展呢，基于1963年苏联宇宙学家尼古拉-卡尔达肖夫创造了衡量宇宙文明等级的假象指数，人类现阶段文明的本质其实就是能量消耗速度（原指可掌握的能源，我将其转换为消耗速度，掌握能源规模和消耗速度应该是正相关）。能源消耗速度越快，文明等级越高（当然距离该文明的毁灭越近）。可以想象世界上的一切先进事物的发展都是基于更快速能量消耗的基础上搭建的 再回到金融市场，此时我们可以想象其最终作用是为了让人类加速能量消耗，资本是人类文明发展过程中的润滑剂和催化剂，激发着人类对更多能源的渴望，从而可以让人类开发更多的技术来控制使用更多能源并消耗它。同时借助于电子科技的发展，现在金融交易处理速度和交易规模也已经今非昔比，十分的高效且庞大。我们可以预见在不久的将来，人类会越来越多的采用人工智能技术，自动化交易等科技手段来进行金融交易，其结果使资本流动更加高效，从而促进人类科技进步，加速能源消耗速度。 脑洞来了：我们看过很多科幻片假设人类有一天会被人工智能，人类核战争，人类和机器的战争等，通过外部物理方式毁灭。但，基于以上假设，我在设想这样一个可能性，人类文明有没有可能从内部自身瓦解？例如：有一天因为一个小小的小概率事件的出现，而已有交易规则策略并没有很好的处理，又因人工智能量化交易趋同，自动化交易导致一些列不可逆的链锁交易，触发严重的金融市场风险，导致全球金融市场崩溃。并最终触及到现实中的能源链条，能源消耗戛然而止，形成严重的能源危机，进而导致人类文明停滞乃至毁灭。这好像是一个金融科技（fintech）科幻题材硬核小说，算不算一个新题材？ 其实类似的场景不是没有发生，例如安然事件和美国最近一次的金融危机CDS，都有这样的影子。但随着科技水平的不断发展，系统所带来的影响将会越来越快速和广大。能源消耗速度是一个双刃剑，能源消耗速度越快出现问题后果越严重并更难以恢复（很多人认为这也必是人类文明毁灭的最终解，至于是哪个具体毁灭形式，就可以无限遐想一下了）。我想这个一个朴素的认知，所以可以猜想今后可能出现更为严重的金融问题。 编一个这样的故事应该需要很多专业知识。我们原先设想过的人工智能，核战争等毁灭方式也许真的不会出现，毕竟人类已经预见了，所以会有意识的避免吧。问题总是出现在你没有想到的地方。这也是墨菲定律的一种场景吧，人类在有意识的封堵已经预见的问题，但潜在问题有很多，并必然有可能发生。我想金融市场建立之初必然有一个基础假设（基本的互信基础？），人类是基于该假设的基础上进行金融市场搭建的，但如果一次严重的金融危机可以触及到这个假设基础，那就有可能毁灭整个市场。那么基于墨菲定律，虽然这个概率很小，但是只要存在，并必然在未来某个时刻可以发生。 思想漫游，收～～～ 此文章最多也就是灾难题材小说的一个胡思乱想，我还没有认可在我在有生之年会遇到这样的事情。毕竟人类文明等级太低了，太阳还在壮年，我们还没有遇到外星人…….😂]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fixed Income Securities]]></title>
    <url>%2F2021%2F10%2F08%2Ffixed-income%2F</url>
    <content type="text"><![CDATA[FX市场看完后，打算看看固定收益证券（Fixed Income Securities）相关知识，其实主要想学习一下债券（bonds）相关知识。大部分情况下我们可以将固定收益债券与债券划等号，虽然有时也会把优先股认为是固定收益证券中的一种 此篇阅读主要解答一下问题： 哪些特征定义了固定收益证券，这些特征如何确定计划的现金流量？ 与固定收益证券相关的法律、监管和税务考虑有哪些，为什么这些考虑对投资者很重要？ 支付利息和还本付息的常见结构有哪些？ 哪些条款可能影响固定收益证券的处置或赎回？ 介绍从总市值来看，固定收益证券是全球最普遍的筹资方式。固定收益证券是一种允许政府、公司和其他类型的发行人向投资者借款的工具。任何借钱都是债务。 固定收益证券的承诺付款通常是发行人对投资者的合同（法律）义务。对于公司而言，固定收益证券与普通股的不同之处在于没有所有权。与普通股股东的债权相比，支付利息和偿还本金（借入的金额）是对公司收益和资产的优先债权。因此，理论上，一家公司的固定收益证券的风险低于该公司的普通股。 针对债券这里有很多基本概念需要牢记： 债券发行者 issuer 债券到期日 maturity 债券面值 par value 票面利率 coupon rate 债券频率 frequency 货币面额 currency denomination 先学习一下，稍后再更新……]]></content>
      <categories>
        <category>finance economics</category>
      </categories>
      <tags>
        <tag>CFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Currency Exchange Rates]]></title>
    <url>%2F2021%2F09%2F24%2Fcurrency-exchange-rates%2F</url>
    <content type="text"><![CDATA[系统学习金融基础知识，还有对应的英文表达。后面也许用的到，机会都是留个有准备的人，哈哈～ 以下内容仅作为学习笔记，此章节学习目标： 定义汇率并区分名义汇率(nominal exchange)和实际汇率(real exchange)以及即期(spot)和远期(forward)汇率 描述外汇（foreign exchange FX）市场的功能和参与者 计算和解释一种货币相对于另一种货币的百分比变化 计算和解释货币交叉汇率(cross-rates) 将以点数(points basis)或百分比表示的远期报价转换为直接的远期报价(outright forward quotation) 解释即期利率、远期利率和利率之间的套利关系 计算和解释远期折扣或溢价(premium) 计算和解释与即期汇率和各货币利率一致的远期汇率 描述汇率制度(regimes) 解释汇率对各国国际贸易和资本流动的影响 介绍通过阅读此章节介绍才知道，外汇市场交易如此巨大，是我们熟知的证券市场50倍，真正的全球市场，全时区，个人和机构都能参与的市场。让我对其有了新的认识。同时我好奇的是，如此巨大的市场，为何Reading的篇幅却很少，也许看完后我就有答案了。 计划尽快阅读完此章节，先读一个周末看看进度，毕竟是第一次深入阅读CFA，10月还有个假期，应该是可以完成的，看看能多快完成吧其实很久之前就想看了，时间就这么流走了，现在学习也不迟 学习总结花了5天时间看完此篇章，比想象的速度还是慢了一些正如学习目标中所列出的内容，除了最后两项，前面所列出的内容相对还是容易理解的。预计今后会主要用到直接汇率报价（direct currency quote）和间接汇率报价（indirect currency quote），以及即期汇率和远期汇率相关知识和计算 而最后两项内容感觉很多的涉及到了经济学原理中的相关知识，例如供需曲线和弹性定义。读起来有点晦涩难懂，只能理解个大概了 意外惊喜今天在公司内部的教育平台上搜索CFA课程，竟然发现有一全套视频，开心。公司肯花钱买教育资源给员工，这才是公司给员工最好的福利。👍]]></content>
      <categories>
        <category>finance economics</category>
      </categories>
      <tags>
        <tag>CFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mind Sorting]]></title>
    <url>%2F2021%2F09%2F11%2Fclean%2F</url>
    <content type="text"><![CDATA[最近发生了不少的事情，让我做一下思绪整理，希望通过这种方式让我的思路更清晰 好事多磨有些好事情确实需要很多时间，例如我上一次的等待就是3个月以上的事情，貌似这次好像还会更长一些。关于此事，目前看还是有变数存在，结果可期但未知，具体事情就先不细说了。还好个人心态算是平稳的，几乎可以忽略其带来的影响相关两个事情： Haskell 8月底前已经看完一遍，最近先放下了，如果此事情有进一步发展，我觉得我还是有时间再提前深入一下的 最近项目上人员调整的动作很大，按照计划，10月开始我会开始担当更为重要的团队沟通角色，这也将会是一个不小的挑战。前期讨论已经开始了 量化交易这个词对于我来说不新，2016年时就已经有所耳闻，包括高频交易。最近又开始引起我的关注，因为相关服务平台逐渐完善，以及机器学习相关技术的结合，很多新一代的个人投资者都开始关注和使用此方法。我也开始想深入一下，之前只是简单了解，现在可以借助一些平台提供的服务接口实际操作一下 利用闲暇时间，首先开始学习相关的Python包和交易行情数据分析方法等通过近一年的个人理财投资，对于基金投资有了一些体会，感觉还是很适合我的投资理念希望今后可以尝试使用一些量化交易策略 冥想和读书最近也开始练习正念冥想，并尝试调整个人睡眠质量，初步感觉是有益的，还需多加练习冥想目的是放松，给自己积极鼓励，更好的直面困难，接受当下，进而可以做到更好🧘‍♂️ 有时会感觉没有什么事情可以做，这时想起了读书。去年此时买的经济学原理还没有看完，最近又拾了起来。当然也会读一些闲书，放松一下大脑，享受一下时光除了看一些英文学习视频外，也会找英文读物和书来看，让自己的英语更好一些 不要奢望有很多事情可以做此类事情，其实真的很少，一周也就几个小时，需要好好计划和利用 结尾最近的锻炼又少了一些，需要积极调整一下，好想去游泳 本周有同事离职去了新加坡，去那边永居。通过此事让我思考了一个事情。有的人喜欢挑战改变，有的人喜欢安于现状稳定，二者孰优孰略？其实并不好说，更像是阴阳太极，平衡变与不变，找到自己的平衡才更重要。我清楚知道我想要的，他人清楚自己的想要的，这就很好，大家都可以获得向往的满足。 发散思维：人人都想要改变，那世界将是一片混乱，处处都是”战争”。如果人人都安于现状，那世界将死气沉沉，毫无活力和发展]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haskell Study 2]]></title>
    <url>%2F2021%2F08%2F15%2FHaskell-Study2%2F</url>
    <content type="text"><![CDATA[继续上次阅读进度，进行后续内容的学习感觉学习速度明显减慢，后面的内容难度上来了，开始变得复杂需要更多的实验来理解 本来此文章15号就创建了，以为2周内可以看完的书，结果又多读了一周多，本周二（24号）终于看完了一边花了3周多的时间终于看完了 Learn You a Haskell for Great Good! ，中间有两章看的十分慢，因为概念有点涩，难懂，还有2～3点没有理解的十分清楚虽然已经看完了一边，书中代码基本也都敲了一遍，但还是感觉有点云里雾里的，囫囵吞枣，很多细节还需要通过实践进行深入，还在等待中…… 先说说我的整体感觉吧，不一定准确，仅供参考 Haskell 的语言发展背景我没有太多了解，直观感觉是一帮计算机或数学方面的领域专家设计的，因为如下特点： 纯函数式编程思路，复杂的嵌套调用规则，类似数学公式一般的推到过程。（这也是我第一次在写基础练习时，为了搞清楚代码调用关系，使用了草稿纸进行规则公式般的推导，让我想起了高等数学） 类似高等数学公式一样的书写方式 () $ &gt;&gt;= :- -&gt; 等等，还让我第一次知道了 Reverse Polish Notation 大量的递归操作思路，不仅仅在逻辑实现上，也在类型定义和方法实现上，和传统解决思路有很大的区别 123456789data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show) data Direction = L | R deriving (Show) type Directions = [Direction] changeToP :: Directions-&gt; Tree Char -&gt; Tree Char changeToP (L:ds) (Node x l r) = Node x (changeToP ds l) r changeToP (R:ds) (Node x l r) = Node x l (changeToP ds r) changeToP [] (Node _ l r) = Node 'P' l r 和传统编程语言相比，除了递归，当你在haskell中遍历操作一个数据集合，很少看到传统的Loop循环操作 1map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]] 一个逻辑多种实现途径，至于选哪个？呵呵，我可能记不全，也没有太好的感觉，还需要磨练一下 很多易与传统编程混淆的概念，例如 data type newtype class instance，千万不要用传统语言直接理解他们，和你知道的不一样 书中问题Learn You a Haskell for Great Good! 中还是有不少需要纠正的地方，猜测Haskell版本更新导致了一些变化，本书并没有及时更新。（为何不把它share到wiki上，大家一起维护？💡） 前几章中应该也有几个小问题，我没有记录。下面列举的问题，是从 Input and Output 章节开始记录 使用random，是需要安装 random package 的，cabal install –lib random random (mkStdGen 100) show内容和书中已经不一样了 random reads 我没有能正常调用它，如何fix还需要再看看 B.pack [99,104,105] 展示内容不再包含empty 异常 catch 需要导入 import Control.Exception.Base vowels 这个方法我没有找到，不知道如何使用 1234567import Data.Monoid lengthCompare :: String -&gt; String -&gt; Ordering lengthCompare x y = (length x `compare` length y) `mappend` (vowels x `compare` vowels y) `mappend` (x `compare` y) where vowels = length . filter (`elem` "aeiou") fail 没有找到 1234instance Monad Prob where return x = Prob [(x,1%1)] m &gt;&gt;= f = flatten (fmap f m) fail _ = Prob [] Monad包中的内容发生改变，原来import Control.Monad.Writer，现在需要import Control.Monad.Trans.Writer Error 类型已经废弃，替换使用Except import Control.Monad.Trans.Except 书中还有几处的代码可以优化的，并没有特别记录下来，稍后可以分享一下我敲的书中实例代码。 开发体验 visual studio code + Haskell 插件，这个组合还是很给力的，语法高亮，代码优化推荐，quick fix提醒，快速查看文档，对于我这个初学者受益匪浅 https://hoogle.haskell.org/ 这个网站很重要，可以查询方法使用，部分包含实例，也可以定位源码，便于深入理解 Idea + Haskell 插件和 VS Code 相比差了很多，暂不推荐 ghci中常用指令 :m :l :t :k :i :q 大量时间依赖他们去理解代码 编译指令和解释运行指令 12ghc --make &lt;file&gt;.hsrunhaskell &lt;file&gt;.hs 至今不会运行时的debug，如何解？ JVM 运行 Haskell你想在JVM中运行 Haskel 语法的代码吗？ 找到两个利用JVM运行Haskell代码的方式 ETA 通过构建说明，无法加载eta资源，没有运行成功。如有需要，稍后再尝试了 Frege 这个搭建成功，成功运行Haskell示例代码，并且它还有一个还在更新的idea插件支持，感觉还不错 感觉如果今后要是想把Haskell迁移到JVM环境，这是个思路。 两个资源都是BSD 3-clause开源协议 亦或是学习一下scala ?直接迁移，谁知道呢，知识尚浅，稍后再比较了P.S.目前的我，如果不写Java，还是更喜欢写Python，呵呵。 后话从网上找了两本Haskell编程的书，2019年出版的还是很新的，其中应用场景为金融数据分析，和我后面要做的事情应该比较接近。已经小一个月了，后续的事情还没有确定，好事多磨，好事多磨啊～ 希望后续一切顺利吧确定后，会开始深入Haskell的一个具体应用。 最近工作和学习内容一起忙乎，并且连续两个周末都在家学习，有点疲惫。这几天没什么事情的话，就只想好好提升一下英语，计划周末去听一个2个小时的英语专场，去看Ryan Reynolds 演的《Free Guy》😛 这个周末对我很重要，很重要～～～～ 题外话个人投资的部分基金回撤严重，这次算是学到了一些，选择的行业，问题还不是很大，只好耐心操作，补仓拉低成本，等待回调 收～～期待一个普通又不普通的周末]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haskell Study 1]]></title>
    <url>%2F2021%2F08%2F08%2FHaskell-Study1%2F</url>
    <content type="text"><![CDATA[一切内容从这里开始 Learn You a Haskell for Great Good!目前看完了第六章Higher Order Functions先说一下总体感觉： 这是一个纯Function 编程语言，Function是第一公民，没有严格语法语义，非常灵活 读到现在，我感觉被各种语法糖🍬围绕着，熟悉面向对象编程的朋友们，我觉得你会发现这里的标准写法像是各种语法糖。糖有点多～ 如果学习Python是难度为3的话，我觉得学习Haskell应为7或8，满分10分。我的上线标准，应该是Rust吧。 感觉官方网站没有给出太多直接的文档，当然不如Python文档来的直接，不知道语言推广者是怎么考虑的 读到六章末尾时逐步发现很多晦涩难懂的语法糖写法，其实有更容易让人理解的书写方式，并深深感觉到其中数据公式的味道 目前都是代码片段和语法讲解，没有看见全貌，看看Modules开始有没有更多应用开发，工程构建相关的内容 工程为什么要选择Haskell，这是我一直关心的问题，选择它一定是有它的优势所在，这个可能稍后才能找到答案，先说说目前看到的Haskell语言特点： Purely Functional，纯函数，这个前面说到了，函数套函数，一切都可以为函数，可以把函数当作参数，可以把函数进行嵌套，组合等等。反正你的思维方式就是：我要用哪些函数，如何编排来完成我的task Lazy，惰性，Haskell可以按需调用，可以延迟表达式评估，直到其被需要或者访问为止，避免资源浪费，从而减少功能执行时间。这个话听的是不是没啥感觉，我目前的理解是： 12345-- 这里将无限循环产生奇数[1,3..]-- 而这里只会拿到前五个奇数，后面的无限循环消失了-- 我理解为这是惰性的体现，如果以后我发现错了我会纠正这里take 5 [1,3..] Package，Haskell是开源的，其也有包管理平台，大家维护了很多实用的包，这一点也符合现代语言的特性 Statically Typed，每个表达式的类型都是在编译时确定的。如果在运行时不匹配，程序将被编译器终止 Type Inference，与Python类似，Haskell可以做类型推断。他还有Typeclass 这样的概念，可以表示范型接口，对类型进行约束。 开发环境 和 相关信息现在使用 Visual Code 加 Haskell 插件进行练习其实也发现了Idea中也有相关的插件，稍后再试试吧 对于初学的我来说，Hoogle 是非常需要的，可以查找各种function的解释，甚至是源码相当于hackage.haskell.org中文档的专属搜索 前六章总结 基本语法，命令行模式下一通敲，没啥好说的 定义自己的模块文件baby.hs 在里面写了一些方法，通过:l 进行加载（前面是小写L哦，通过这个指令我猜出了:q指令😛） 基本类型，[char] 和 String 是相同的，Int 和 Integer 是不同的，还有其它基础类型 Type variable 相当于范型，Typeclasses 是类型接口约束，它的底层具体实现我没有看，官方文档中Eq的源码竟然没有，额～～～ 函数定义，多条件处理，以及方法内的where使用，Let In定义即使用。_ 和 ｜ 的使用 递归使用，Python也可以做到类似的效果，原理一样，就是在function编程模式下，code可以更为极致 常用function讲解，map，filter等。Lambda表达式写法（\），我很喜欢，思路一下子简化了不少。而foldl和scanl的相关用法，让我我思考很久 $ 和 . 这两个对function的简化感觉很好，我想我今后会经常使用的 后续任务和问题 学完这个教程先 如何构建一个工程，如何编译运行 如何debug，如何排错，如何了解其运行时状况及性能 总结利用周末时间看了此教程，总体学习速度不是很快，很多点需要反复理解。网上相关资料也不是很丰富，感觉是个较偏的语言但，这个语言的学习给我带来了不一样的思考方式，十分有意思。会对我今后其它语言的学习使用或功能设计开发有帮助。 题外话顺便看了一下Java8到Java16的变化，下一个LTS版本是17，计划年底切换到17上有几个新特性还是值得期待的。才发现flight recorder 这个挺有意思，还有JMC Python的学习和AWS的学习还在继续，稍后会写一些这方面的总结吧。找时间，找时间～ 时间有限啊，想做的事情太多。对了，周末尝试学习了一下冥想🧘‍♂️，额～我睡着了～呵呵。后面再练练，激发正念～ 由于最近周围地区疫情有所抬头，暂停了游泳活动，很不开心。为了保持体力，每天500个跳绳+拉伸运动走起。 团队入职了一些新人，周二给他们做个培训，不知道以后会怎样～]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haskell 安装]]></title>
    <url>%2F2021%2F08%2F01%2FHaskell%2F</url>
    <content type="text"><![CDATA[如果一切顺利，后面应该需要开始使用Haskell 这个函数式编程语言。 今天要解决的问题是Haskell基础环境搭建，即安装问题当然如果你的网络条件正常，一句话就可以搞定安装： 1curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh 本人使用mac os系统，详情是可以从https://www.haskell.org/downloads/ 这里获得 那这么简单的事情有必要写个文章记录一下吗？ 有的，很不幸，我所在区域这个网站需要代理才可以访问。而且我的软路由已经报废（为了省钱和时间，近期不打算再买了），所以我需要尝试通过其它方式解决此问题。 环境描述 MacBook Pro 11.5 系统，个人感觉后面描述的方法和具体版本号无关 网络受限，不可以直接访问Haskell官网，看来没啥人用这个语言，或者…… 具备一个Http代理可以通过其访问 方法一 网络全局代理应该是最简单的方法，通过配置全局网络代理实现。我使用Wi-Fi网络，指令如下： 12345678networksetup -setwebproxy Wi-Fi &lt;IP&gt;:&lt;PORT&gt;networksetup --setsecurewebproxy Wi-Fi &lt;IP&gt;:&lt;PORT&gt;# enablenetworksetup -setwebproxystate Wi-Fi onnetworksetup -setsecurewebproxystate Wi-Fi on# disablenetworksetup -setwebproxystate Wi-Fi offnetworksetup -setsecurewebproxystate Wi-Fi off 当然这和你在System Settings &gt; Network &gt; Wi-Fi &gt; Advanced &gt; Proxies &gt; Web Proxy 设置是同理的当然你还应该需要设置Secure Web Proxy，毕竟安装访问路径是Https的 BUT， 这个方法对于我来说是行不通的，因为我的公司电脑权限受限，没有权限可以在网络中修改代理。 方法二，Terminal中的代理如前所提到的，大家可以一眼看出安装指令其实是执行一个shell安装脚本在Terminal中运行，那我们就尝试将Terminal设置代理就好了 本人使用.bash_profile来进行terminal的环境配置，添加如下指令来启动terminal代理 1export http_proxy="&lt;IP&gt;:&lt;PORT&gt;" 注意这里不携带代理协议，例如http:// 只是terminal代理还是不够的，因为安装shell脚本使用的curl进行下载，该指令有自己的代理，还需要创建.curlrc文件来设置curl的代理。文件中内容为： 1proxy = "&lt;IP&gt;:&lt;PORT&gt;" 也是不包含代理协议，为什么这样做，而不是使用 -x 或者 –proxy 来指明curl的代理呢，原因就是：配置一次curlrc，搞定所有curl指令，简单啊。现在就可以通过代理安装Haskell了。 此方法同理可以使用到Linux系统中，如果以后遇到了，到时再尝试了值得注意的是，Linux系统的http_proxy是应该指明代理协议的 其它方法除了软路由，我还知道另一个方法那就是通过其它代理工具将Mac系统中http请求都拦截并代理出去。当然这也需要管理员权限去安装软件和允许一些代理操作，例如更新证书链等大家可以自行尝试 题外话：网络限制关于网络限制，个人观点：我是十分理解的，但也深受其”害”，浪费了很多时间，也学到很多知识。在我们这里，如果你不懂点网络代理相关知识，你都无法成为一名优秀的程序员（呵呵，说笑了） 作为程序员，平时会发现很多技术网站收到限制。我虽然可以保证自己的行为，但是谁可以保证全网人民的行为是得当呢所以网络限制是可以理解。 没有限制的自由将会是无序 题外话：本周上线小结本周做了一次系统上线，去修复一个production issue（我之前挖的一个坑），review一下： 这个issue 本可以避免，今后应该注意和其它团队的沟通，不能做Assumption，要Confirm 从发现Issue到解决，速度还是很快的，5天之内，完成修复，走完上线流程，拿到各种approval，并上线成功 关于PT的Dispensation，PT Header的判断虽然带来了一些额外effort，但是也从中学到一些新观点，还好通过个人努力按时解决了，没有耽误上线 下周回归新项目组，开始新的功能实现 P.S. 周五无意间闪到了腰，S**T现在还有点酸痛，弯腰费劲]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Datetime in Java 8]]></title>
    <url>%2F2021%2F07%2F24%2Fdatetime%2F</url>
    <content type="text"><![CDATA[按照之前说的，今天总结一下时间相关的类和方法。 在使用Java 8 之前，大家应该使用过 Joda Time Library 吧。Java 8 中的时间相关类就是源于这个Lib 废话不多说，开始总结一下。 这里说的package为Java 8 及以上中的 java.time package, 讨论其中的相关class和方法 为何引入新的时间包既然引入新的，那说明老的不好用呗。其新特点在于： 线程安全，按照源码注解所示：This class is immutable and thread-safe 很容易使用，方法更容易理解，更适合人类常规使用习惯和思维方式 更好的时区处理和支持 LocalDate名字很直接，当地日期，基于系统时钟获得 1LocalDate localDate = LocalDate.now(); 如何format也是大家经常使用的功能 12localDate.format(DateTimeFormatter.ISO_DATE);localDate.format(DateTimeFormatter.ofPattern("yyyy/MM/dd")); 还是很容易的，可以使用系统已经预置的format格式或者自己自定义，或者可以使用DateTimeFormatterBuilder进行更复杂的自定义 时间解析也是很直观 123LocalDate.of(2021, 07, 24);LocalDate.parse("2021-07-24");LocalDate.parse("2021/07/24", DateTimeFormatter.ofPattern("yyyy/MM/dd")) 日期的计算 12LocalDate tomorrow = LocalDate.now().plusDays(1);LocalDate previousMonthSameDay = LocalDate.now().minus(1, ChronoUnit.MONTHS); 常用的方法 1234LocalDate.now().getDayOfMonth();LocalDate.now().getDayOfWeek();LocalDate.now().getDayOfYear();LocalDate.now().isLeapYear(); 日期比较 12boolean notBefore = LocalDate.parse("2021-07-12").isBefore(LocalDate.parse("2021-07-11"));boolean isAfter = LocalDate.parse("2021-07-12").isAfter(LocalDate.parse("2021-07-11")); 其它 123LocalDate.now().atStartOfDay();LocalDate.now().with(TemporalAdjusters.firstDayOfMonth());LocalDate.now().with(TemporalAdjusters.lastDayOfMonth()); LocalTime和上面用法基本类似 123LocalTime.now();now.format(DateTimeFormatter.ISO_TIME);now.format(DateTimeFormatter.ofPattern("HH:mm:ss")); 解析时间 12LocalTime.of(6, 30);LocalTime.parse("06:30"); 时间计算 12LocalTime.now().plus(1, ChronoUnit.HOURS);LocalTime.now().plusHours(1); 获取和比较 123LocalTime.now().getHour();LocalTime.parse("06:30").isBefore(LocalTime.parse("07:30"));LocalTime.MAX; LocalDateTime哈哈，内容基本重复了，同上类似，不再赘述了 123456LocalDateTime.now();LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));LocalDateTime.of(2021, Month.JULY, 20, 06, 30);LocalDateTime.parse("2021-07-24T06:30:00"); 其它的自己看吧，不列了 ZonedDateTime &amp; OffsetDateTime用于通过时区和时间偏移方式来支持跨时区的时间操作 123456789101112131415161718Set&lt;String&gt; allZoneIds = ZoneId.getAvailableZoneIds();System.out.println(allZoneIds);// 将新加坡时间转换为巴黎时间LocalDateTime now = LocalDateTime.now();ZoneId asiaSingapore = ZoneId.of("Asia/Singapore");ZoneId europeParis = ZoneId.of("Europe/Paris");ZonedDateTime zonedDateTimeSingapore = ZonedDateTime.of(now, asiaSingapore);System.out.println(zonedDateTimeSingapore);ZonedDateTime zonedDateTimeParis = zonedDateTimeSingapore.withZoneSameInstant(europeParis);System.out.println(zonedDateTimeParis);System.out.println(zonedDateTimeSingapore.format(DateTimeFormatter.ISO_ZONED_DATE_TIME));System.out.println(zonedDateTimeSingapore.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSSZ zzzz")));ZonedDateTime parse = ZonedDateTime.parse("2021-07-24T15:15:30+02:00[Europe/Paris]");System.out.println(parse);System.out.println(parse.withZoneSameInstant(asiaSingapore)); OffsetDateTime 感觉和使用ZonedDateTime类似，一个用时区，一个用偏移量 12345678LocalDateTime now = LocalDateTime.now();ZoneOffset offset = ZoneOffset.of("+08:00");OffsetDateTime offSetByEight = OffsetDateTime.of(now, offset);System.out.println(offSetByEight.toLocalDateTime());System.out.println(offSetByEight.withOffsetSameInstant(ZoneOffset.of("+09:00")));ZoneId asiaTokyo = ZoneId.of("Asia/Tokyo");System.out.println(offSetByEight.atZoneSameInstant(asiaTokyo)); 关于时间格式化样式字符串，发现还是有个很复杂的标准，目前只知道常用的表达，其它格式详细可以参见WikiP.S.之前寻找国家语言等代码也是通过Wiki来找到相应的标准 Period and Duration用于支持日期和时间的区间计算 例如获得两localDate之间的天数 12Period.between(initialDate, finalDate).getDays();ChronoUnit.DAYS.between(initialDate, finalDate); 获得两个time时间的秒数或分钟数 12Duration.between(initialTime, finalTime).getSeconds();ChronoUnit.SECONDS.between(initialTime, finalTime); EpochSecond这个值的处理应该是很常用的，我们在传递数据是还是用原点时间戳数值比较多但是要注意的是，时间戳数值并没有表明时区，但按照Unix系统的定义，我们应该使用UTC时区为基准，计算时间戳，所以都是基于UTC时间转换出的数值你可以使用此工具进行查看epoch converter 如下，同一个时间戳数值，通过不同的offset获得不同时区的localDateTime 1234LocalDateTime utcDateTime = LocalDateTime.ofEpochSecond(Instant.now().getEpochSecond(), 0, ZoneOffset.UTC);System.out.println(utcDateTime);localDateTime = LocalDateTime.ofEpochSecond(Instant.now().getEpochSecond(), 0, ZoneOffset.of("+08:00"));System.out.println(localDateTime); 或者通过ZonedDateTime 1234567891011Instant nowUtc = Instant.now();ZoneId paris = ZoneId.of("Europe/Paris");ZoneId asiaSingapore = ZoneId.of("Asia/Singapore");ZonedDateTime nowParis = ZonedDateTime.ofInstant(nowUtc, paris);System.out.println(nowParis);ZonedDateTime nowAsiaSingapore = ZonedDateTime.ofInstant(nowUtc, asiaSingapore);System.out.println(nowAsiaSingapore);System.out.println(nowParis.toLocalDateTime()); 总结看似简单的时间类，其实还是有很多细节值得注意的还一些不错的方法这里没有一一列出.对于时区和时间戳部分，引发了一些思考，还是有收获的]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure]]></title>
    <url>%2F2021%2F07%2F16%2Fdata-structure%2F</url>
    <content type="text"><![CDATA[书接上回，今天说Java中的数据结构，基于Java 11，相关内容点到为止，可能不会太深入。知道以及够用目的来总结数据结构 将会涉及 Array List Vector Stack Dictionary Set Map Queue Deque Array数组最简单的数据结构, 特点可以多维，可object也可基础类型，大小不可变，当然读取和写入速度快。个人感觉应用场景偏底层，一般不会用于复杂业务数据的处理。与Python中的Array相比，我更喜欢Python（后面开始总结Python，顺手挖坑）使用很简单，不多说 1int[][] array4 = &#123;&#123;1,2,3&#125;, &#123;2,3,4&#125;&#125;; List相比Array，List大家用的应该更多，最多莫过于ArrayList了吧表，里面的每一个item就像是一行，整个数据就是一个表List这个Interface的实现有很多，我们最常用的就是 ArrayList，别问我别的，我几乎没有用过其他List实现 出于好奇查了一下ArrayList和LinkedList，网上有很多比较文章，例如：stackoverflow如果谁在实际工作中使用了LinkedList请告诉我应用场景和理由，感谢先。多数情况下，简单一句话，用ArrayList 就对了。 CopyOnWriteArrayList 是Arraylist 线程安全的变种，没有用过，作为了解看看，如果以后遇到多线程，应该会优先考虑使用它。当然，我们还可以用Collections.synchronizedList方法包裹整个对象，实现线程安全，此方式弊端也显而易见，他将锁定整个对象，性能不高。 Vector &amp; StackList的近亲，Vector继承了List接口，Stack继承了Vector。元老级对象结构，个人不建议使用。两个都是线程安全，并通过synchronized关键字进行同步，效率不高 Vector和ArrayList使用上区别不大，Stack主要是实现LIFO值得注意的是，都是List的实现，所以我们可以这样 12List vector = new Vector(); List stack = new Stack(); 记得当年第一份Java工作还在使用Vector，后来就不在用了（暴露了年龄，呵呵） Dictionary作为抽象类，它的应用场景应该已经少之又少了吧，感觉可以忽略它了。与之相关的提一句HashTable吧，线程安全切使用synchronized关键词，方法同步。HashTable也继承了Map接口，有了ConcurrentHashMap，谁还用HashTable？ Map这个是个重要的接口，常用实现类超多，键值对的数据结构到处都是。先说一个最常用的HashMap，无人不知无人不晓，看看他的源码实现应该会收益匪浅HashMap不是线程安全的，如果再多线程中进行操作，可能会丢失数据哦，为什么，看看HashMap的实现原理你会找到答案的 stackoverflow 如何线程安全，两个方法ConcurrentHashMap, 大多数人应该首先想到的方法，也是最好的方法Collections.synchronizedMap(), 还要有这个隐藏方式，不常用，当然是因为性能不佳 还有LinkedHashMap和TreeMap，虽然我基本不用，尤其是TreeMap好像没有用过三者之间的比较可以看看这个，一目了然。stackoverflow Map还有什么值得注意，ConcurrentSkipListMap，这个建议要深入研究一下。 Set这个数据结构的最大特点就是数据不可以重复，实现类也超多 123Set hashSet = new HashSet(); Set linkedHashSet = new LinkedHashSet(); Set treeSet = new TreeSet(); 根据Map的前车之鉴，这三个类型的对比也就大同小异了。 为了线程安全，和Map相似，有两个方式CopyOnWriteArraySet，线程安全Collections.synchronizedSet(); 或者此方法，不建议使用 当然他还有一个重要的类ConcurrentSkipListSet值得研究一下 Queue &amp; Deque这两个放在一起说，其实有了他们，我们也就彻底废弃了Vector和Stack Queue 是FIFO的数据结构 Deque 是同时支持 FIFO LIFO的数据结构，直接代替带Stack 如何你的数据有顺序要求,并且顺序消费，应该优先考虑Queue。其性能应该更高一些。我应该认真对比一下Queue与List，看看他们的具体使用区别 说一说常见的实现类PriorityQueue，可以比较对象权重来进行数据消费 12345678910111213141516PriorityQueue&lt;Integer&gt; pQueue = new PriorityQueue&lt;&gt;();// Adding items to the pQueue using add()pQueue.add(10);pQueue.add(20);pQueue.add(15);// Printing the top element of PriorityQueueSystem.out.println(pQueue.peek());// Printing the top element and removing it// from the PriorityQueue containerSystem.out.println(pQueue.poll());// Printing the top element againSystem.out.println(pQueue.peek()); ArrayDeque，感觉可以代替到LinkedListLinkedBlockingQueue / LinkedBlockingDeque以及线程安全的数据结构ConcurrentLinkedQueue / ConcurrentLinkedDeque Queue的实现也很多，这个需要点时间好好再挖掘一下，后续有时间我再补充代码 结束语很多数据类型我们平时并不会用到，但是在某些场合下，只有它最合适，所以还是需要了解一下以备不时之需。 下一个目标是什么呢？ Java中的时间好啦，应该比较简单 P.S. Python的总结也该开始了（挖坑，督促自己填）]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread]]></title>
    <url>%2F2021%2F07%2F03%2Fthread%2F</url>
    <content type="text"><![CDATA[来了，来了，如约而至，今天说一下Java中的Thread。 在正式开始前，说一点题外话，最近在翻这些基础知识时，感受到如下： 学习知识最好时一次性系统学习，这样最高效，节省时间，后面只需要通过实践深入就好了 我的记忆一向不是很”可靠”，时间一长很多知道东西就开始模糊了，这个确实需要翻一翻回忆一下。其实还是用得少 之前给同事分享过一个presentation关于K8S的，结果这两天和人聊天时其中一个概念就印象不深了，还好后来回忆起来了 昨天晚上（7月2日）一口气写了六个服务的OCP部署脚步，有点晕，没有感到一丝的成就感，纯体力劳动。吐槽一下，跑题了，收～～ Thread的定义我就不再赘述了，大家还是上网自行查找吧，毕竟我自己描述会不太准确，而每个人想了解的深度也有所不同，是否需要深入到计算机原理层面，请自行决定。这里我所描述的内容，主要是为了帮助自己的记忆和记录一些发现，如果大家想深入还是多看看官方文档和Java源码，然后自己多试试吧 Thread &amp; Runnable线程的开头就是这两个家伙了，Thread class 和 Runnable 接口Java多线程的鼻祖，从1.0版本就有了 我们可以继承Thread 类，也可以实现Runnable 接口 1234567891011121314151617181920public static class NewThread extends Thread &#123; @Override public void run() &#123; long startTime = System.currentTimeMillis(); int i = 0; while (true) &#123; System.out.println(this.getName()); System.out.println(Thread.currentThread().getName() + ": New Thread is running..." + i++); try &#123; //Wait for one sec so it doesn't print too fast Thread.sleep(1000); if (i &gt;= 10) &#123; break; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 如上，你能说出this.getName() 和 Thread.currentThread().getName()的区别吗？以及在什么操作下可以呈现这个区别，如果你可以回答这个问题，我相信你已经深入理解Thread的部分知识 Executors1.5开始就引入了Executors，来声明多线程。此时我们开始关注java.util.concurrent这里我们会关注如下几点 atomic 原子类型 locks 一堆锁，前一篇文章已经提到 Concurrent* 各种并发安全的基础数据结构类型 callable 以及各种Future 实现 以及现在所说的 ExecutorService 相关实现 1234ExecutorService executor = Executors.newFixedThreadPool(10);executor.submit(new NewThread());executor.submit(new NewThread());executor.shutdown(); 常见的有这三个线程池创建方式 123Executors.newFixedThreadPool(10);Executors.newCachedThreadPool();Executors.newSingleThreadExecutor(); 其实都是ThreadPoolExecutor不同参数化有一个比较特殊的 12ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2);executorService.schedule(new NewThread(), 1, TimeUnit.SECONDS); 这个来自ScheduledThreadPoolExecutor方法创建，可以周期执行 此处要注意一个小问题，executor默认不会自己释放，所以需要手动shutdown。shutdown相关有两个方法，区别请自行查找 另一个思考题，你能清晰的认识到以下两个写法的区别吗？ 12executor.submit(NewThread::new);executor.submit(new NewThread()); FutureFuture 接口实现也很多，最常用，最简单使用的莫过于CompletableFuture吧，只需要简单将要处理的内容包裹一下，就可以启动多线程了值得注意的是，supplyAsync 方法默认使用的也是 ForkJoinPool.commonPool()，后面也会提到。 当然也是可以指定自己定义的executor的。 123456CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; "Hello");try &#123; System.out.println(stringCompletableFuture.get());&#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace();&#125; CompletableFuture 在Java9之后完善了很多，添加很多新方法,其实针对completableFuture 就可以单独喝一壶的，大家还是自行去深入吧。这里只是点到为止。CompletableFuture可以将计算步骤形成一个链，合并处理结果，例如： 12345CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; "Hello") .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + " World"));assertEquals("Hello World", completableFuture.get()); 其另一个优势在于，他可以handle异常，例如： 123456789CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; if (name == null) &#123; throw new RuntimeException("Computation error!"); &#125; return "Hello, " + name; &#125;).handle((s, t) -&gt; s != null ? s : "Hello, Stranger!");assertEquals("Hello, Stranger!", completableFuture.get()); 关于completableFuture中方法，每个主要分三类： 普通当前线程方法 Async结尾使用默认ForkJoinPool.commonPool()线程池的，异步方法 Async结尾使用自定义Executor线程的，异步方法 大家自行查看源码吧我也是看了一些网上的文章，大致了解了一下，以后会在实际工作中合适的场下尝试各个功能。 TimerTask刚才提到了ScheduledExecutorService，在其之前还有一个TimerTask创建定时线程的方式，只是了解一下，估计后面不会太多使用了 12345678910TimerTask task = new TimerTask() &#123; @Override public void run() &#123; System.out.println("Task performed on: " + new Date() + "n" + "Thread's name: " + Thread.currentThread().getName()); &#125;&#125;;Timer timer = new Timer("Timer");long delay = 1000L;timer.schedule(task, delay); Callable与Runnable对应，一个只是执行，一个可以返回结果。现在来看Callable使用更加频繁一些同时Callable执行后对应的接受类型为Future类型 123456public class FactorialTask implements Callable&lt;Integer&gt; &#123;&#125;FactorialTask task = new FactorialTask(5);Future&lt;Integer&gt; future = executorService.submit(task);assertEquals(120, future.get().intValue()); ForkJoinPool它的设计目的就是将问题分段处理，逐一解决然后在合并，这就是Fork/Join两个步骤的意思。今后应该会关注其实际应用，貌似应用场景很多，功能非常使用至于Worker是如何管理的，这个我就没有深入研究了，有时间再深入了 默认使用ForkJoinPool.commonPool()，我们也可以自己定义新的ForkJoinPool，例如： 1ForkJoinPool forkJoinPool = new ForkJoinPool(2); 和Thread相比，下面的代码最大的问题你知道是什么吗？记得Thread setDaemon(true)吗？ 12ForkJoinPool forkJoinPool = new ForkJoinPool(2);forkJoinPool.execute(new NewThread()); 如何使用ForkJoinPool，可以创建一个递归任务， RecursiveTask继承自ForkJoinTask 123456789101112131415161718192021222324252627282930313233343536373839package com.gino.thread;import java.util.*;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;public class CustomRecursiveTask extends RecursiveTask&lt;Integer&gt; &#123; private int[] arr; private static final int THRESHOLD = 5; public CustomRecursiveTask(int[] arr) &#123; this.arr = arr; &#125; @Override protected Integer compute() &#123; if (arr.length &gt; THRESHOLD) &#123; return ForkJoinTask.invokeAll(createSubtasks()).stream().mapToInt(ForkJoinTask::join).sum(); &#125; else &#123; return processing(arr); &#125; &#125; private Collection&lt;CustomRecursiveTask&gt; createSubtasks() &#123; List&lt;CustomRecursiveTask&gt; dividedTasks = new ArrayList&lt;&gt;(); dividedTasks.add(new CustomRecursiveTask(Arrays.copyOfRange(arr, 0, arr.length / 2))); dividedTasks.add(new CustomRecursiveTask(Arrays.copyOfRange(arr, arr.length / 2, arr.length))); return dividedTasks; &#125; private Integer processing(int[] arr) &#123; System.out.println(Arrays.toString(arr)+"processed by " + Thread.currentThread().getName()); return Arrays.stream(arr).filter(a -&gt; a &gt; 10 &amp;&amp; a &lt; 27).map(a -&gt; a * 10).sum(); &#125;&#125; 运行代码 12345678CustomRecursiveTask customRecursiveTask = new CustomRecursiveTask(new int[]&#123;1, 2, 3, 11, 12, 32, 12, 54, 22, 20, 19&#125;);ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();// 这两行分别运行一下，观察他们的区别，你会发现什么？Integer compute = customRecursiveTask.compute();Integer compute = forkJoinPool.invoke(customRecursiveTask);System.out.println(compute); 最近实验了不少，先记录这些吧。写这些内容主要是为了自己的学习总结，并不是为了知识分享，所以内容不会很细致讲解到位。看到的人，如有疑问可以自己搜索相关细节，深入研究。 代码都是来自网络，自己稍加修改。 题外话其实这篇文章7月3日就创建了，由于个人时间紧张迟迟没有时间完成，现在是7月11日凌晨1点，终于总结完了。 窗外已经开始下雨，如果按照预报说，白天可能还会有大暴雨。 如果没有，我就继续去游泳，自由泳换气转体还是差很多，继续改进。鞭腿推进力不足，还是有些吃力，难道这就老了吗？不服～～哈哈 下一个总结目标，各种实用的基础类型，各种list map queue deque等，应该是数据结构方面]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swim️]]></title>
    <url>%2F2021%2F07%2F03%2Fswim%2F</url>
    <content type="text"><![CDATA[最近”沉迷”于游泳🏊，基本上每周一游（恨不得一天一游，工作、时间、金钱貌似都不太支持这个频率😂），一次会游3～4个小时吧。 小时候学过游泳，但是超级怕水，记得当时学游泳，每次上课前都很痛苦，心里十分的抗拒。并且那时的教练也是”简单粗暴”式教学，不会考虑个人对水的反应。简单说，在个人对水的恐惧心里下，我基本没有学会啥。 不知何时起，我不再对水那么恐惧，可以用很平常的心态对待它，也开始享受在水里的快乐。正好最近可以带着家人一起游泳，借这个机会把游泳自学起来。 通过一段时间的练习，蛙泳终于可以一次游满25米了（1.5米浅水区泳道长度），换气技巧也得到提升，可以用鼻子在水下吐气，抬头嘴换气。水性有了不少的进步，可在水中停留和做一些基本动作，但应该还没有达到开阔水域自救能力 下一步练习计划，在增强水性的同时，开始自学自由泳和练习踩水。最近跟着 “梦觉教游泳” up主，从基础练习，感觉很系统，并且解答了我很多之前的疑问 小提示💡：浮板很重要，各个练习阶段都用的上它，最近正在用浮板练习自由泳鞭腿，之前用它练习蛙泳腿。现在我的练习装备是：泳衣，泳帽，泳镜和浮板 希望这个夏天过后，可以自由泳小成，下深水区游一圈。我也打算就这样么一直游下去，加油～～越来越感觉游泳是最好的运动，对身体关节损伤小，还可以增强心肺功能，冷热刺激对身体也好，防止心血管疾病 题外话我还有个小想法，要不要冬天开始学滑板🛹 这样我就又多了一个代步工具。能到自如刷街层面就好，要求不高。 下半年的小期待： Metroid NS 新作，已经好久没有新作了。突然让我想起另一个系列，瓦里奥大陆，希望有一天可以在NS上发布新作 Macbook pro 14，钱已经准备好，就等发布了]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stop Loss]]></title>
    <url>%2F2021%2F06%2F19%2Fstop-loss%2F</url>
    <content type="text"><![CDATA[最近有几件事情（与投资无关）有点不顺，需要尽快止损。对于我来说最大的目的就是节约时间。损失的是钱和之前支出的时间，有点可惜，但也只能如此了，停止一切与之相关的后续操作，才是明智的选择。 钱和时间主要损失在 一台服务器 一个网络硬件 一个开源工程 反思，其中服务器损失是可以避免的，以后设法改进。还有其它不顺的事情就不一一列举了。生命在于折腾，也要学会止损。 近期还是先放下，忘却，止损～～～～～这样才能有更多时间做更有意义的事情]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lock]]></title>
    <url>%2F2021%2F06%2F08%2Flock%2F</url>
    <content type="text"><![CDATA[锁，多线程开发的基础，线程安全结构的基础，今天研究一下锁 说到多线程，我们还会想到synchronized关键字，锁和同步块相比，区别是什么？先说结论，锁比同步关键字更实用，建议用锁 Lock 是 interface, Synchronized 是关键字. Synchronized 自动释放锁, Lock 需要手动释放. Lock 在等待时可以被打断, 但是Synchronized 不可以，需要一直等待. Lock 明确知道是否有锁, 但是Synchronized 做不到. Synchronized 是CPU悲观锁机制，多线程时需要频繁切换CPU上下文，Lock是乐观锁机制，多线程是性能更高. Synchronized 可以用于class, methods, 和代码块, Lock可以用于代码逻辑 Synchronized 不能实现公平锁， Lock 可以实现 Lock Interfacejava.util.concurrent.locks.lock 常见实现ReentrantLock直接代码，来自网络 1234567891011121314151617181920212223242526272829public class SharedObject &#123; //... ReentrantLock lock = new ReentrantLock(); int counter = 0; public void perform() &#123; lock.lock(); try &#123; // Critical section here count++; &#125; finally &#123; lock.unlock(); &#125; &#125; public void performTryLock()&#123; //... boolean isLockAcquired = lock.tryLock(1, TimeUnit.SECONDS); if(isLockAcquired) &#123; try &#123; //Critical section here count++; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; ReentrantReadWriteLock读写锁，读等待写，写等待读 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SynchronizedHashMapWithReadWriteLock &#123; Map&lt;String,String&gt; syncHashMap = new HashMap&lt;&gt;(); ReadWriteLock lock = new ReentrantReadWriteLock(); // ... Lock writeLock = lock.writeLock(); public void put(String key, String value) &#123; try &#123; writeLock.lock(); syncHashMap.put(key, value); &#125; finally &#123; writeLock.unlock(); &#125; &#125; public String remove(String key)&#123; try &#123; writeLock.lock(); return syncHashMap.remove(key); &#125; finally &#123; writeLock.unlock(); &#125; &#125; Lock readLock = lock.readLock(); public String get(String key)&#123; try &#123; readLock.lock(); return syncHashMap.get(key); &#125; finally &#123; readLock.unlock(); &#125; &#125; public boolean containsKey(String key) &#123; try &#123; readLock.lock(); return syncHashMap.containsKey(key); &#125; finally &#123; readLock.unlock(); &#125; &#125;&#125; StampedLockJava 8 新引入的一个锁实现，可以返回stamp，用其解锁或检查锁是否还有效 12345678910111213141516171819202122232425262728293031323334353637public class StampedLockDemo &#123; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); private StampedLock lock = new StampedLock(); public void put(String key, String value)&#123; long stamp = lock.writeLock(); try &#123; map.put(key, value); &#125; finally &#123; lock.unlockWrite(stamp); &#125; &#125; public String get(String key) throws InterruptedException &#123; long stamp = lock.readLock(); try &#123; return map.get(key); &#125; finally &#123; lock.unlockRead(stamp); &#125; &#125; public String readWithOptimisticLock(String key) &#123; long stamp = lock.tryOptimisticRead(); String value = map.get(key); if(!lock.validate(stamp)) &#123; stamp = lock.readLock(); try &#123; return map.get(key); &#125; finally &#123; lock.unlock(stamp); &#125; &#125; return value; &#125;&#125; Condition 接口条件接口可以定义自己的条件约束，制定等待逻辑 1234567891011121314151617181920212223242526272829303132333435public class ReentrantLockWithCondition &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); int CAPACITY = 5; ReentrantLock lock = new ReentrantLock(); Condition stackEmptyCondition = lock.newCondition(); Condition stackFullCondition = lock.newCondition(); public void pushToStack(String item)&#123; try &#123; lock.lock(); while(stack.size() == CAPACITY) &#123; stackFullCondition.await(); &#125; stack.push(item); stackEmptyCondition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public String popFromStack() &#123; try &#123; lock.lock(); while(stack.size() == 0) &#123; stackEmptyCondition.await(); &#125; return stack.pop(); &#125; finally &#123; stackFullCondition.signalAll(); lock.unlock(); &#125; &#125;&#125; 总结还有一些细节没有深入研究。ConcurrentHashMap中同时看到了synchronized和ReentrantLock身影 下次应该总结一下Thread了吧]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Functional Interface]]></title>
    <url>%2F2021%2F06%2F07%2Finterface-function%2F</url>
    <content type="text"><![CDATA[最近在重新学习Java Core，看到Functional Interface. 做个小总结。 何为Functional Interface？ @FunctionalInterface 可以看到很多这样的注解，其实注解只是标识而已。本质是Any interface with a SAM(Single Abstract Method) is a functional interface, 有一个抽象方法定义的接口就是Functional Interface它常常在Lambda表达式中使用，无需匿名类，直接实现方法定义。 让我们看看常见的Functional Interface，都式如何使用的 常见接口比较 接口 方法 功能 Consumer accept 一个入参，无法返回结果 Function apply 一个入参，有返回结果 Predicate test 一个入参，true or false 返回结果 Supplier get 无入参，有返回结果 Comparator compare 一个入参，正数，0，负数返回结果 极简演示1234567891011121314Consumer&lt;String&gt; consumer = System.out::println;consumer.accept("consumer");Function&lt;String, String&gt; function = x -&gt; x + " gino";System.out.println(function.apply("Hello"));Predicate&lt;String&gt; predicate = x -&gt; x.equals("Gino");System.out.println(predicate.test("Gino"));Supplier&lt;String&gt; supplier = ()-&gt;"Supplier";System.out.println(supplier.get());Comparator&lt;String&gt; comparator = String::compareTo;System.out.println(comparator.compare("1", "2")); 思考题查看Comparator 源码，为什么 Comparator 有两个抽象方法定义，他却是functional interface呢？想一想，你会找到答案的。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Code and Think]]></title>
    <url>%2F2021%2F06%2F04%2Fthink%2F</url>
    <content type="text"><![CDATA[你熟悉数据结构和算法吗？个人以为：对于大多数程序员或者开发工程师答案都是否定的吧。在我说出此话的同时，你也可以猜到我此方面的能力了。 其实，在我看来，可以专心写代码，追求代码质量的工程师是令人羡慕的。那个过程如同艺术家在完成自己心爱的作品；如同科学家在专心论证自己的假设，如同一位匠人在追求那凡人无法企及的技艺。 然而，现实中一位IT工程师的工作不是这么”简单”的。多数情况下每日书写代码时间不会超过4个小时。为何如此，原因各有不同，我想不少人会有此问题。 心态当有一天你发现，看着手中的工作，你所积累的经验和你想象中的目标有差距时，你会怎么办？我会选择顺其自然，放下一些执念，做好当前该做的事情，时不时的享受一下生活，这一切不是挺好吗？ 那还要尝试新东西和改变吗？当然要，但心中不是想着”一定要怎样”，而是放平心态。尝试会有两个结果： 让自己更加了解自己，思考以及启发，成长于此过程中 发现自己的积累还可以做些其他事情，给自己一个改变的机会。 这个过程有些微妙，如同心中湖水平如镜时，也会有那突然涟漪泛起一刻，而你会去欣赏和感受，直到再此平如镜，看着镜中的自己更加清晰。 可能有人会说，你不抱着”一定要怎样”态度去做事情，不会成功。我不反驳，但要想清楚何为成功。 简单说：我愿意保持平常心去尝试一些机会，如果感觉还不错可以投入一些精力，毕竟想把事情做的有点模样，投入还是不可少的。 代码说回Code或者是一段program，我喜欢这样描述它，它是对一组规则的描述。人类有很多语言，计算机也是如此。在我看来，所有语言都可以用于描述所有事物（或规则，我喜欢把周围的一切都看成”规则” 这个话题今后有机会儿再聊）而学习一门计算机语言也如同学一门外语一样，你通常掌握的只是描述事物的表达方式。 那数据结构和算法的晦涩难懂，又是一个什么感觉。其如同你学习了英语，可以用于日常沟通。突然有一天，在法律场景下，你需要用法律专业措辞描述一个场景。没错，就是这样一个感觉，你需要熟悉很多专业词汇，术语，如同数据结构；你需要搞明白法律相关基本规则和思维逻辑，如同算法。所以一时有点蒙也是很正常的。面对这样的场景，这时你有一个主动问题，你想做吗？ 还有一个被动问题，有机会做吗？ 此时不得不承认，如果你有相关经验的积累，你获得此次机会的概率会高一些。毕竟你一眼看去会很快懂得相关的数据结构和算法的设计意图和目的。如果你没有，你可能很长时间都无法理解其想表达的本意，也就无从下手描述具体规则细节了。此时你的”想做”可能就变得微乎其微了。 此时回到最初的话题，心终会平静，如果还想，那就投入一些精力。如果接受现状，那就放下。此时我更愿意放平心态做一些事情，平衡生活和工作，平衡兴趣和专业。保持学习心态 下面说点实际的吧，最近遇到的一些有趣的程序。本人平时工作中很少遇到此类场景，偶尔遇到值得深入一下 数据结构这个问题实际上我至今没有搞清楚，没有清楚的部分是此结构使用的场景和存在的意义（要解决什么问题）。 构建此结构是基于一个代码说明文档（非Java语言）实现的，所以只有猜测着写了。就像我之前所说，如果你没有相关经验，可能一时间无法理解其真实意义，构建具体逻辑也就变得困难了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.gino;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Map;import java.util.function.Function;import java.util.stream.Collectors;import java.util.stream.IntStream;public class MyEither&lt;L, R&gt; &#123; private List&lt;L&gt; left = new ArrayList&lt;&gt;(); private List&lt;R&gt; right = new ArrayList&lt;&gt;(); private final Class&lt;L&gt; leftClass; private final Class&lt;R&gt; rightClass; public MyEither(Class&lt;L&gt; leftClass, Class&lt;R&gt; rightClass) &#123; this.leftClass = leftClass; this.rightClass = rightClass; &#125; public boolean hasLeft() &#123; return this.left.size() != 0; &#125; public boolean hasRight() &#123; return this.right.size() != 0; &#125; public boolean isLeft(L value) &#123; return this.left.contains(value); &#125; public boolean isRight(R value) &#123; return this.right.contains(value); &#125; public L fromLeft() &#123; if (hasLeft()) &#123; L l = left.get(0); left.remove(0); return l; &#125; else &#123; return null; &#125; &#125; public R fromRight() &#123; if (hasRight()) &#123; R r = right.get(0); right.remove(0); return r; &#125; else &#123; return null; &#125; &#125; public void put(Object value) &#123; if (this.leftClass.isInstance(value)) &#123; this.left.add((L) value); &#125; else if (this.rightClass.isInstance(value)) &#123; this.right.add((R) value); &#125; else &#123; throw new ClassCastException(); &#125; &#125; public List&lt;L&gt; getLefts(Function&lt;List&lt;L&gt;, List&lt;L&gt;&gt; fun) &#123; return fun.apply(this.left); &#125; public List&lt;R&gt; getRights(Function&lt;List&lt;R&gt;, List&lt;R&gt;&gt; fun) &#123; return fun.apply(this.right); &#125; public Map&lt;L, R&gt; map() &#123; int i = Math.max(left.size(), right.size()); return IntStream.range(0, i).boxed() .collect(Collectors.toMap(index -&gt; index &gt; left.size() - 1 ? null : left.get(index), index -&gt; index &gt; right.size() - 1 ? null : right.get(index))); &#125; public static void main(String[] args) &#123; MyEither&lt;String, Double&gt; myEither = new MyEither&lt;&gt;(String.class, Double.class); myEither.put(10D); myEither.put("test"); myEither.put(101D); myEither.put(102D); System.out.println(myEither.hasLeft()); System.out.println(myEither.isLeft("test")); System.out.println(myEither.getLefts(x -&gt; x.stream().map(String::toUpperCase).collect(Collectors.toList()))); System.out.println(myEither.hasRight()); System.out.println(myEither.isRight(10D)); System.out.println(myEither.getRights(x -&gt; x.stream().map(v -&gt; v / 100D).collect(Collectors.toList()))); System.out.println(Collections.singletonList(myEither.map())); // negative case try &#123; myEither.put(10); &#125; catch (Exception e) &#123; System.out.println("wrong type"); &#125; &#125;&#125; 结构阐述 左右两个元素，类型不同，最初实现只是单元素，看到文档中有获取左右元素的list类型返回，修改为list类型左右元素 根据不同类型放置到左右两边 map转化是有问题的，当右元素长度比左元素长度多2及以上时，map转换是有问题的。 由于不了解其使用场景，所以总是感觉其存在价值不大，为何不用直接用Map处理呢？ 写此结构时还是锻炼一下Java基础，有收获的 算法经典算法题，硬币问题，非贪婪算法 题目描述：如有你手里有面值为1，7，10的货币（也可设定为其它组合），数量充足。现给出一个具体金额，你如何找到货币个数最小的组合 废话不多说，直接上答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.gino;import java.util.*;import java.util.stream.Collectors;public class Coin &#123; public static List&lt;List&lt;Integer&gt;&gt; solutions = new ArrayList&lt;&gt;(); public int count(List&lt;Integer&gt; coins, int num, int charge, List&lt;Integer&gt; solution) &#123; if (charge == 0) &#123; solutions.add(solution); return 1; &#125; if (charge &lt; 0) &#123; return 0; &#125; if (num &lt;= 0 &amp;&amp; charge &gt;= 1) &#123; return 0; &#125; List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(solution); solution.add(coins.get(num - 1)); return count(coins, num - 1, charge, copy) + count(coins, num, charge - coins.get(num - 1), solution); &#125; public static void main(String[] args) &#123; System.out.print("Enter your charge: "); Scanner scanner = new Scanner(System.in); int charge = scanner.nextInt(); Coin coin = new Coin(); List&lt;Integer&gt; coins = Arrays.asList(1, 7, 10); System.out.println(coin.count(coins, coins.size(), charge, new ArrayList&lt;&gt;())); System.out.println(Arrays.toString(solutions.toArray())); List&lt;Integer&gt; min = solutions.stream().min(Comparator.comparingInt(List::size)).orElse(new ArrayList&lt;&gt;()); System.out.println(Arrays.toString(min.toArray())); List&lt;List&lt;Integer&gt;&gt; collect = solutions.stream().min(Comparator.comparingInt(List::size)).stream().collect(Collectors.toList()); System.out.println(Arrays.toString(collect.toArray())); System.out.println(solutions.stream().mapToInt(List::size).min().orElse(0)); &#125;&#125; 我给出的解决方法是其中一种，非动态规划（说实话，那种我没有看懂）此解题思路还是很有意思的，使用递归，核心思想是：在尝试路径中，要么钱减少，要么货币种类减少，列举所有组合可能性，获得最终结果 程序输出了所有组合的可能性，以及寻找到最优解。感觉这个解题思路和睿智，思路来自于网络。收获： 解题过程的思考，很有意思 Stream的实际场景使用 简单应用一个实际场景应用，其实也是数据结构问题，但是这个使用场景明确，所以容易清晰实现思路 主要思想，寻找最近汇率数据，或给定搜索日期，查询当日最新的汇率数据。不多解释了，代码很容懂。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.gino;import java.time.LocalDate;import java.time.LocalDateTime;import java.util.*;public class FxRate &#123; class Item &#123; LocalDate localDate; String assetName; Double value; LocalDateTime localDateTime; public Item(LocalDate localDate, String assetName, Double value, LocalDateTime localDateTime) &#123; this.localDate = localDate; this.assetName = assetName; this.value = value; this.localDateTime = localDateTime; &#125; public LocalDateTime getLocalDateTime() &#123; return this.localDateTime; &#125; &#125; List&lt;Item&gt; cacheList = new ArrayList&lt;&gt;(); public Map&lt;String, Double&gt; getData(LocalDate localDate, List&lt;String&gt; assetNameList, Optional&lt;LocalDateTime&gt; localDateTime) &#123; HashMap&lt;String, Double&gt; result = new HashMap&lt;&gt;(); if (localDateTime.isEmpty()) &#123; for (String assetName : assetNameList) &#123; Item item = cacheList.stream().filter(x -&gt; assetName.equals(x.assetName)).filter(x -&gt; localDate.equals(x.localDate)).max(Comparator.comparing(Item::getLocalDateTime)).orElse(null); result.put(assetName, item.value); &#125; return result; &#125; else &#123; for (String assetName : assetNameList) &#123; Item item = cacheList.stream().filter(x -&gt; assetName.equals(x.assetName)).filter(x -&gt; localDate.equals(x.localDate)).filter(x -&gt; !localDateTime.get().isBefore(x.localDateTime)).max(Comparator.comparing(Item::getLocalDateTime)).orElse(null); result.put(assetName, item.value); &#125; return result; &#125; &#125; public void addData(LocalDate localDate, String assetName, Double value, LocalDateTime localDateTime) &#123; cacheList.add(new Item(localDate, assetName, value, localDateTime)); &#125; public static void main(String[] args) &#123; FxRate fxRate = new FxRate(); fxRate.addData(LocalDate.of(2020, 4, 1), "USDSGD", 1.33, LocalDateTime.of(2020, 4, 1, 10, 40)); fxRate.addData(LocalDate.of(2020, 4, 1), "USDAUD", 1.29, LocalDateTime.of(2020, 4, 1, 10, 40)); fxRate.addData(LocalDate.of(2020, 4, 1), "USDSGD", 1.34, LocalDateTime.of(2020, 4, 1, 14, 30)); fxRate.addData(LocalDate.of(2020, 4, 1), "USDAUD", 1.28, LocalDateTime.of(2020, 4, 1, 14, 30)); fxRate.addData(LocalDate.of(2020, 4, 2), "USDSGD", 1.31, LocalDateTime.of(2020, 4, 2, 8, 40)); fxRate.addData(LocalDate.of(2020, 4, 2), "USDAUD", 1.30, LocalDateTime.of(2020, 4, 2, 8, 40)); fxRate.addData(LocalDate.of(2020, 4, 2), "USDSGD", 1.29, LocalDateTime.of(2020, 4, 2, 14, 30)); fxRate.addData(LocalDate.of(2020, 4, 2), "USDAUD", 1.32, LocalDateTime.of(2020, 4, 2, 14, 30)); List&lt;String&gt; assetNameList = Arrays.asList("USDSGD", "USDAUD"); Map&lt;String, Double&gt; result = fxRate.getData(LocalDate.of(2020, 4, 1), assetNameList, Optional.empty()); System.out.println(Collections.singletonList(result)); result = fxRate.getData(LocalDate.of(2020, 4, 1), assetNameList, Optional.of(LocalDateTime.of(2020, 4, 1, 14, 20))); System.out.println(Arrays.asList(result)); &#125;&#125; 其实代码还有”优化”空间，还可以把方法继续简化，但是炫技、代码可读性、代码性能还是要平衡一下的，我觉此状态已经不错了。代码写的太复杂，过后自己读起来也是痛苦的。收获： 一个实际问题解决的思考过程 Optional 和 Stream的使用，此类处理可以使用parallelStream哦 我真的是记忆不好，很多方法调用还需要去查，还是用的太少，如果天天写也形成”肌肉记忆”了 总结再说几句相关感受，最近在给团队面试候选人，不知道各位对现在的面试什么感觉？我的是： 面试难度往往大于实际工作难度，我也是这么做的，问了一些超出实际工作的问题 应试般的准备一些问题，”套路”式的问与答，是否真的可以解决今后的问题不知道。（大厂带出的风格，你不刷题，都不好意思参加面试） “客观”考察技术，忽略”人格”属性。满足基本条件时，能做与想做，你要那一个？面试往往无法充分了解一个人 这样的面试有问题？有点问题，但是无法避免，因为你需要在短时间基于标准内量化，评定一个候选人就不可避免。如果我今后遇到此类问题，我应该都刷刷leetcode然后再去面试吗？顺其自然吧～ 哈哈～ 个人观点，欢迎交流，不必”认真”，一切随缘。 题外话最近在思考学习、投资、生活、孩子教育等问题，四十不惑，心态也在发生着细小的变化，眼光需要放远些了。 上周末参加了 PMP 和 MBA 两个活动，多和人交流感觉还不错的。老师也在说，大家都是有那么一股拼劲所以才会聚到一起。我现在更想把这股劲使到更有”价值”的点上，这是我目前的需求。一两句无法说清，有机会以后再说吧。 收～～～]]></content>
      <categories>
        <category>tech</category>
        <category>note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Niu Year]]></title>
    <url>%2F2021%2F02%2F21%2FYear%2F</url>
    <content type="text"><![CDATA[新年新气象，今年一开始就有很多新挑战，工作、生活皆有之。 牛年，希望一切顺利吧。 额～～2020我一年啥也没写，忙糊涂了，哈哈 Openwrt 入坑今年一开始就折腾这个东西，入手一个R4S，照猫画虎的自己编译了固件。 学到不少，也感觉浪费不少时间，过年这几天天天实验固件，基本上啥正事也没干 好吧，现在基本达到了我的使用预期，我就先放放吧。 Agile Squad公司开始实行新一轮的re-org，打乱当前分组去推行新的项目开发方式，将agile推向下一个阶段。 我也借此加入了一个新的小队，去完成一个大的项目。简单说目前感觉还不错，近一段时间可以比较专注的做件事情了 而公司的release流程变得原来越复杂了，具体细节略过。 Agile的开发和复杂的release，额～～～ 中间的CI/CD，啥时可以解决这些问题 Graphql &amp; AWS最近开始全面使用 Graphql 在新的项目上，同时开始熟悉AWS相关知识 继OCP迁移之后，云步伐继续前行，下一站AWS 结束语我想赚更多钱，为了今后养老。呵呵～～～ 虽然俗气，但是真实～]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go]]></title>
    <url>%2F2019%2F12%2F27%2FGo%2F</url>
    <content type="text"><![CDATA[简单说，又好久没有更新了，貌似”死”了一般，2019眼瞅就要过去了，不出意外的发现自己貌似什么都没干。 言归正传，最近再次放假，利用一些时间把Go语言学习一下，这个flag已经立了一年了，才开始初见行动，惭愧。 学习方法极客时间 Go语言教程 和 Go官方tour教程个人感觉快速学习基础只是还是官方教程更有效一些，如同当年学习Python一样，官方教程还是直接一些。 我的发现列出几个个人认为的Go语言特点，也是总结，帮助自己和他人更好的理解Go语言 类型位置后移，例如变量，方法返回值类型，与常见语言相比，类型的位置都后移了 1var i int 切片（slice）需要认真理解，它是一个特殊的结构，底层直接操控不可变的数组。目前来看，大多情况应该使用slice而非array切片的快速生命和python的数组截取很想，但是本质完全不一样，python是生成了新的数组对象空间，可以说是新的副本，修改不会印象原始数据Go的切片不是，他是一个array的抽象引用结构，对切片的操作直接会影响原始数据 Go有指针，但不能像C++那样做指针操作，他只能用于传递调用 Go没有类，只有结构体。我们可以给结构体类型或自定义类型添加方法，其便利性在于，Go语言会自动做指针和对象的转换，比起普通方法更加灵活。 12345678910111213141516171819202122232425262728293031package mainimport "fmt"type Vertex struct &#123; X, Y float64&#125;// 类方法func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;// 普通方法func ScaleFunc(v *Vertex, f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(2) ScaleFunc(&amp;v, 10) p := &amp;Vertex&#123;4, 3&#125; p.Scale(3) ScaleFunc(p, 8) fmt.Println(v, p)&#125; 结束语这个文章烂尾了，其实是没有开始就结束了。😛]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误（Wrong）]]></title>
    <url>%2F2019%2F10%2F19%2Fwrong%2F</url>
    <content type="text"><![CDATA[错误，今天算是犯了一个错误，影响评估不大不小，中等水平，耽误了全家人一天的时间，路上开始反思，趁现在感觉还在记录下来，引以为戒吧错误的具体内容不再细说了，说出来有点丢人😛，只说说分析结果吧 反思结果（self-examination）以下都是抽象总结，你可能不能充分了解而感到困惑，没关系，毕竟这是给我自己看的，此处有点自私了，抱歉🙏 做错的 对确定机会的犹豫，没有主见，过度考虑周围人的想法，是此次错误的重要导火索，未能充分从自身需求角度出发评估事情的价值 盲目将后续事务交与他人并未充分参与后续过程评估，最终造成错误发生 做对的 意识到错误已经形成不能改变时，正确的情绪管理，避免错误影响扩大 事后积极分析，总结教训，避免后续类似事情再次发生 代价 一天的时间损失（少量的资金损失，这个可以忽略不计） 给家人带来的疲惫和不悦 对不起～～希望今后我可以用更为积极心态对待每一次机遇，每件事情，并努力做到最好，谢谢家人！ 不确定（uncertainty）生命中充满了不确定，隐约感觉好像有神灵在我周围一直帮助我一样，让我感受、思考与遇见]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[放假（Block Leave）]]></title>
    <url>%2F2019%2F08%2F02%2FBlock-Leave%2F</url>
    <content type="text"><![CDATA[放假结束～第一次放block leave，现所在的公司很有意思，规定必须休block leave，不休年底会认为你违规，因此我终于休了我工作以来第三次连休年假(三天以上)。 Block Leave本周结束，过的还算充实。带孩子去周边自驾玩了一圈，孩子很开心，而我的精神迟迟没有完全放松下来，担心放假前正在执行的项目，还有安排了缺没有进展的代办任务。这种感觉让人很矛盾，也不舒服。虽然这几天同事找了我几次，询问几个问题，感觉到项目还是问题不少，但也只能回去再处理，工作永远也做不完的（公司规定，block leave期间不可以访问公司系统） 关于工作在此期间我也思考一些问题，其实也是对多年不同经历的思考： 软件开发项目的设计和文档，怎样做才算好？ 有哪家公司做的是值得参考的。 我多年来的工作更多是计算机应用，那么计算机科学价值何在？有谁关注吗？ 如果不亲自参与开发其中，管理者是否可以了解团队实际工作情况、困难、压力，进而有效激励团队，帮助团队成长呢？ 团队成员目标不一致时，无法有效组织团队形成工作协作，这个团队还是团队吗？ 看到这些问题时，你的理解可能与我想表达的并不一样，因为所面对的具体事情（场景）只有我最清楚，当抽象成标准问题时，信息也就压缩地丢失了。其实这几个问题都这个共同点，我们在实际工作中怎么把握细节和抽象。完成task需要细节，这将十分耗费精力。而管理者又不可能知道所有细节，这时就可能产生沟通、理解等方面的gap。 我之所以现在还在写代码，也是因为我感觉，如果我不能深入细节也就无从总结出抽象。开发团队的扁平化管理，其实也有此意，大家都需要深入细节工作，进而形成自组织的有效协作团队。但假设前提是，团队成员的目标一致。 在我看来，如果一个人可以做细节的事情，是非常幸福的，因为简单且有既得的成就感。但往往又是底层琐碎的，可能会很心烦。 其它我用假期的一天时间，洗了牙——现在感觉好舒服，还看了《哪吒》电影，非常推荐。关于电影，我看了一些网友的评论，有的说并不喜欢，说没有想象中的好，这和我的个人感觉十分不一致，我觉得超好看。它虽然改变了原著，但是改的挺好，整个电影叙事、制作、细节处理都可圈可点，十分精彩。看到一些人对它并不买账，有些不能理解。其实客观想想，大家的思想不一样也很正常，毕竟每个人想法是不同的。相比想法不一致，我更想知道其理由和判断的依据，这样也许才可以有所对比，再审视自己的判断 还有一件讨厌的事情就是，自驾出行游玩回来，下高速ETC竟然没有刷上，然而现场工作人员由于前方车辆处理的某种原因给我误抬了杆（个人推测），所以我也就出了高速，电话咨询了一下ETC管理中心，告诉我下次上高速会补上，到时会怎样我也不知道了，可能需要人工处理，有点小郁闷。 叨叨这些仅是记录一下近期的感受，好了不说了，去学习了。 我还有我的个人目标要实现～～～]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从单元测试到近期总结（Unit Test）]]></title>
    <url>%2F2019%2F05%2F16%2FUnit-Test%2F</url>
    <content type="text"><![CDATA[一周一周过的真快，感觉没做什么，一周时间就这么流荡过去了。本周主要任务有两项，其中一项就是单元测试。写过单元测试的朋友们请举手，哈哈，虽然看不到，估计不是很多。写过有效单元测试的请举手，估计又少了一些。那么今天就从单元测试说起，最后聊聊最近的一些想法 初识单元测试不知大家工作经验如何，对于我来说，工作很多年，单元测试未曾好好写过，如果你现在所在公司在做单元测试，恭喜你，在我看来你多半在一家靠谱的公司。 继续上一篇的话题，项目迁移工作已基本初见效果，现在要开始整理单元测试了，众所周知在系统证实上线前，测试工作不能少。同时还要考虑到今后DevOps的应用场景，所以单元测试的代码覆盖率要提上去，并且今后是要通过Sonar等系统生成相应的测试报告的。 那么什么是单元测试呢，顾名思义只测这一小块，一个小的Unit。那其关键点在于Mock，从而做到功能实现类之间的解藕。对，解藕～～ 怎么做以前，我在使用JUnit包时，仅仅是围绕@Test进行的function的编写，并实际触发相应类的全部功能，从而实现具体功能的测试。编写困难，测试消耗时间也长。你需要考虑初始化是每个对象所需要的依赖以及相应的参数才能创建数真实的调用类。 应该怎么做呢，此次项目整理过程中，我尝试了两个单元测试框架Mockito和JMockit。前者得到spring的官方推荐，后者则是开源社区热捧。两者语法迥异，针对我的目前用到功能来说，功能基本一致。两个框架的核心就是通过合理Mock进行有效的单元内部测试，尽可能将依赖层分离。 听起来不是很难对吧，但实际要复杂的多，由于程序自身架构设计的原因，每一层都有一些更为深入的dependency的调用需要进行Mock，同时你还清楚的知道那些逻辑是需要真实用运行，不能进行简单Mock的。这个过程我正在结合当前项目进行实验，也许今后可以总结出一些有用的东西分享。 结对编程和TDD这两个说法估计做点技术人的并不陌生，但还是那个问题，有谁真的做过呢，又是具体怎么做的呢，效果如何，能回答这些问题的人估计也是寥寥无几。 近期的公司培训让我对此有了初步的认识，有效的单元测试不仅仅是简单的代码覆盖率，还有合理的测试用例的设计。总结以下几点： 不会写单元测试的程序员，不是好程序员 单元测试代码覆盖率应该做到100% 测试用例设计应该从业务需求角度设计，不应该从实现功能代码角度设计，测试用例满足，即功能实现（TDD） 结对编程，可以一人写测试用例，一人写功能实现，两者交叉验证 完整的单元测试开发量与功能实现开发量比例应该在 2:1 至 3:1 在我看来，我一直认为有必要写单元测试。但最近让我更加深入的认识到，其作用和目的，以及其编写时考虑的问题。 性能测试（PT）测试有很多种，单元测试是开发人员要做的工作，那么上线前的测试环节还有SIT UAT PT等，今天在公司初步学习了Performance Test（PT）性能测试。我们经常提到的压力测试，就被包含在其中。PT会包含： Peak Test Stress Test Soak Test一般通过这三个阶段的测试，收集系统运行数据，并形成报告，看测试是否通过或者查找问题。PT具体内容也不少，此迁移项目最后也是要上PT来验证迁移效果，所以后续也会有所总结再分享，这里就不多说了。 近期工作的感受最近工作，看似简单，没有什么高科技含量的工作，但也能从总学到不少东西，正好也弥补我之前工作中的不足，让我更为深入的思考和体会一些技术细节，不失为一件好事情。还是喜欢技术，对于技术我从未放弃，自己也在不断的提升，希望不要落下什么，最近也在系统的学习一些成熟技术框架。 题外话近期看了巴菲特的伯克希尔哈撒韦公司股东年会直播。第一次看，了解到很多，主要是见识一下场面😛巴菲特和芒格两人的处事风格让我深深感觉到他们多年的自律和积淀，两位老者很放松，很睿智，这样的高龄还可以如此洒脱，真是难得啊，让人无比羡慕。股东的提问也很发散，展示出其公司治理中，股东大会的一个特色，让人感觉其管理体制的完善和包容至于经济问题，我就听听热闹，我也没有持有他们的公司的股票，也没有啥钱去炒股，随波逐流而已。 至于近期工作，英语口语沟通可能还是最大问题，不是不能沟通，只是沟通效果不好。关键问题在于印度口音的英语我实在是……希望今后不要把我带跑了 你有这样的感觉吗，人越活会越孤独，是心灵孤独的那种，因为可以感同身受理解你的人会越来越少。我有时会思考这个问题，感觉会呢。 我的时间规划要在合理一些，感觉太多事情想做，时间太有限了。效率也要提升才可以。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>engineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构(Refactoring)]]></title>
    <url>%2F2019%2F04%2F28%2Frefactoring%2F</url>
    <content type="text"><![CDATA[近期正在做一个升级项目，将公司原有的老系统升级，在升级过程中遇到很多有意思的问题，正好近期有参加代码重构课程的培训特写此文章记录一些内容。 项目重构关于项目重构，主要升级项目整体搭建架构，依赖包升级，基础框架升级等，为了保证项目顺利阶段性上线，项目需要分阶段升级，现在为第一阶段 工程Maven化，此前项目为纯Java工程，Jar本地化，首要解决工程构建管理方式，决定采用Maven，此处几乎没有难点，需要注意的有： 打包需要包含的文件，例如package中的xml文件，除class文件maven默认情况下将不会将其打入包内 maven引用本地jar包，由于此项目的历史原因，部分jar现在不再公司中央仓库中，所以先采用临时本地包的方式引入maven 依赖包maven管理，注意依赖包的重复引用，排除多Jar版本等 基础架构升级 升级相关Jar版本，并保证版本中的class依赖关系正确，遇到class废弃导致的依赖class消失等问题 引入spring boot，以及相关组建包，JDBC ORM等 替换原有web.xml，改为通过spring boot servlet注册方式实现 cxf servlet升级，解决mapping冲突等 改变资源文件位置，整理配置文件，更改证书加载方式等 其他升级 连接池升级，引入HikariCP链接池 调整Hibernate配置属性，解决connection释放问题 采用slf4j和logback实现方式整理log，导入原有log配置 目前，第一阶段进展顺利，基本不涉及代码改造，已经将整体框架进行了迁移 其中读到最有价值的文章是：Spring揭秘–寻找遗失的web.xml 另外还使用了spring boot中的actuator，用来做工程加载情况 再看重构第一阶段进入尾声时，公司安排的 clean code培训，重点讲解了代码重构，时间点刚刚好。此次培训收获还是很多的，至少让我从更加系统和最佳实践方面了解了软件工程 重构应该分为两个层面： 架构级重构 上面的项目重构第一阶段，可以说是架构级重构的一小部分，其更多是指对项目整体架构的调整升级，例如从单机变为集群、集群与分布式、引入容器化部署、使用消息中间件解藕等 代码级重构 这个是此次培训的重点，其指导思想更多用于开发人员开发过程中，例如：模块合理划分、设计模式基本原则、降低代码复杂度、领域模型、代码解藕、TDD、DDD等 代码重构此项目的第二阶段必然会涉及代码重构，但是能做多少现在还不确定那么此次培训重点都有什么呢？ 从系统业务分析到功能开发设计，如何分解、拆分、思考，实现类关系图和时序图，这也是最关键的两个设计文档 代码过长、箭头代码、代码复杂度过高问题解决思路 代码拆分、优化、实现可扩展 基本原则，单一职责、扩展才继承、委让更为灵活，接口为了暴露 代码自身解释原则，合理进行注释 领域模型的价值，泛化类型带来的问题，避免数据泥潭 编译时错误和运行时错误，不要”吃掉”异常 DDD TDD的最佳实现，有效单元测试设计和结对编程实践 以上这些内容具体处理方法，参考马丁 福勒(Martin Fowler)重构思想实现 结束语要成为一名合格的软件开发工程师这些内容是我们应该熟知和掌握的，今天算是抛砖引玉，以后还要更多实践。 此外，一个团队中只有一两个人知道这个是不够的，需要通过合理的方式和工具使团队可以运用这些方法，实现整体能力提升才有价值。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>engineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假日随笔]]></title>
    <url>%2F2019%2F04%2F06%2F20190406%2F</url>
    <content type="text"><![CDATA[假期和家人一起度过，尤其是和孩子一起，陪他们玩耍，陪他们成长是令人开心的事情。 周五一早去祭奠了逝去的亲人，我一直在想离世的人是不是去了四维空间（或者更高维的空间），人世间的轮回可能真的存在，做为三维空间的我们无法证实罢了。 高维空间如果真的存在，那么平行宇宙呢？应该也存在吧，记得很早之前和同学讨论过，人生如果是游戏，那么他就是没有存档一条命通关游戏。其实不是没有存档，也不是一条命，只是在你的宇宙中这样，在平行宇宙中有其他的可能，也就是其他的存档。你游戏中的一个存档会知道另一个存档的存在吗？当然不会，如同一个个独立的进程，知道他们的只有更高层的管理层也就高维空间。 基于这样的假设，我们离开这个世界应该至少要去五维空间以上才有意义，有人说应该是六维空间，我还没有想到还差哪一维？也许我死后才能知道吧，首先我们应该接受我们在三维空间的约束。 那么在三维空间我们应该怎么做，建立的自己的信心，努力做好这一平行宇宙中的你，体会你完整的人生，照顾好自己的家庭，学习、感受更多，不断超越自己。 近几个月来，我思想层面所经历的感受可能远远超出了我之前两年所经历的。有挑战、有改变、有不一样的东西的进入你的人生，你才会有所成长，有所领悟，有所感。或者更加准确的说，近期的事情激发了我多年来的感受，突然有所思考（质变都是需要量变积累的） 同事分享了一个图片，极好的解释了我近期的感受，之前我在朋友圈我已经提到离开舒适区的想法，现在克服掉恐惧区，然后你会得到一个不一样的世界 Balance，Balance，Balance，我在寻找那个点，在寻找那个最终的舒适点，也许它对我来说永远都不会存在，对于这个平行宇宙的我不存在，但我还是要去努力寻找，我要做的是战胜自己。 感谢我周围所有人与事（老了开始喜欢回忆了），我还念的和怀念我的，你们给我了这一切的感受、领悟。尤其要感谢我的家人，你们是我的一切～ 前几天我突然想到一个命题，貌似其实每个人最终都难逃一个宿命，就是你将会越来越孤独，每个人的独一无二的感受、经历与领悟，使只有你自己理解自己，你无法理解他人，他人也无法理解你，最终世界在塑造一个独一无二的你，然后将会抛弃你，如同身体排除掉一个衰老的细胞一样。 暂停一下，想想你现在为什么会这样？你的思想、你的所为，其实是这个宇宙塑造了你，当有一日你将离开这个世界，你才会发现何为人生真正的意义。但现在这一个刻，我难逃和世俗间的友人一样，去追求我想要的。 最后说一下语言，其实有时他阻碍了我们的交流，如果对于高维空间生物可以直接思想交流来说的话，三维空间的语言交流绝对是最直接的降维打击，硬生生将最有价值的领悟具像化后才能传播，如同将信息做了有损压缩后传播，还原后还能保证原来所有的信息吗？ OK，如果你一直阅读看到了这里，我也是佩服你了，你也许已经糊涂了。这个随笔的思维很跳跃哈～有点分裂感吗？也许以后我会说的更简单明白一些。😛这是我的随笔，先记录下来，也许等我老了，我可以进行整理，写一本情感类科幻小说。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Skill Tree]]></title>
    <url>%2F2019%2F03%2F24%2FJava-Skill-Tree%2F</url>
    <content type="text"><![CDATA[让我梳理一下，作为Java工程师我们应该掌握的知识点和技能。作为整理总结也好提醒自己你还差什么，如有补充欢迎提醒 Java 基础Java基础当然是围绕JDK展开，JDK的不断也在提醒我们需要与时俱进不断更新相关技能，Java基本语法规则除外，应该掌握熟知以下内容 常用类型相关： String StringBuffer StringBuilder，基础类型和包裹类型、Vector、不同的List、Map，以及ConcurrentMap 异常处理：Exception和Error，final、finally、finalize 动态代理和反射，动态生成Class 输入输出流、IO处理方式、NIO 强引用、软引用、弱引用、幻引用 常见设计模式：Adapter、Proxy、Factory、Singleton、Observer等等 多线程，线程安全、synchronized、ReentrantLock，并发包中的常用工具类，例如：CountDownLatch、BlockedQueue等、线程池和CAS操作 JVM基础，Java类加载过程、JVM内存区域划分，堆内、堆外使用诊断、常见的GC机制及优化 Java新特性Lambda表达式、Stream等 常见算法Java实现，LeetCood刷刷题 通讯协议 JSON XML，虽然xml已经被淘汰，但是还是需要了解的，毕竟还有很多老系统在使用 HTTP Restful，已经成为最常见的通讯方式 RPC 例如：Dubbo、gRPC、Thrift，非常常见及普遍使用 WebService SOAP，已经很少使用 RMI，较少使用 MQ Queue Topic，不同MQ厂商细节与写差别，需要分别对待 TCP/UDP Socket，最传统的方式但是还是需要掌握的 常用框架 Spring 全家桶，Spring mvc、Spring boot、Spring cloud，至于其他类似框架，我就不学了，遇到再说了。 Netty，经典网络请求框架，广泛使用，以及老牌apache mina Guava，Google开发的Java工具包、核心库里面有丰富的功能 Disruptor，高性能吞吐处理框架 这里会设计大量并发设计模式可以深入研究 数据库 JPA、Hibernate、MyBatis，数据类型、事务等 MySQL 广泛使用的关系型数据库，内容很多 Oracle 大型企业商用场景 DB2 金融行业为主 Redis、mongodb（不推荐使用） ElasticSearch 全文搜索，Log日志处理ELK 其他：PostgreSQL、TiDB 数据库，停留在实际项目中使用过，并不深入，懂得基本常用功能，可进行表设计，不熟悉数据库优化和其他复杂维护操作。 其他技术 Linux、Docker、K8S、DevOps Tomcat、Nginx Https及证书、域名 DNS、CSDN、Load Balance 常用云服务 ECS、OSS等 Git SVN 其实以上内容，不少也适用于其他语言的工程师，例如Python和Go等 先整理这些，内容还将不断丰富，已督促自己全面掌握和使用。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Full Stack, Bye ~]]></title>
    <url>%2F2019%2F03%2F11%2Ffull-stack%2F</url>
    <content type="text"><![CDATA[最近和同事聊起全栈开发，让我想写此随笔记录一下，也分享一下我的理解。欢迎交流指正 何为全栈 What is full stack?网上的概念解释很多，大家不妨自己搜搜。我说说的直观感觉，就是前后端都写，啥都可以开发。 其实全栈可以说是一个概念，是一种技术实现方式，但不应该是个职位或者个人要成为的目标。 哪里需要全栈 Where need full stack？一个团队干的活，由一个人或几个人全栈开发完成，你说哪里需要他？ 初创型小公司，人力紧张的团队，抑或是你在做一个私活项目等等。不难看出，这不是一个专业团队该有的开发模式。全栈是个概念，大家都希望用最小的投入做最多的事情，用一个中技术解决所有问题，这个想法是好的，但它违背了事务发展的基本规律。全栈可以是种技术描述，表示一种技术可以适应绝大多数开发场景，但你可知道这将带来多大的开发制约性？做过项目的朋友估计都可以举出很多个例子来解释以上场景。回到最初的问题，哪里需要全栈？没有钱的项目需要全栈，它其实不想技术术语反而更想管理术语。来做全栈工程师吧，潜台词是：活多钱少人手紧，最好你一人都干了。用全栈技术吧，潜台词：这个技术还不错，尽量用它做所有技术实现，虽然不一定都很顺手将就着实现就好了。 再见全栈 bye full stack虽然我也经历过全栈开发，但最终，我个人是不赞同全栈开发的。汽车生产如此高效是因为流水线，流水提出最核心的内容其实是非全栈思想，不应该由一名工人安装一辆汽车，而是每类工人负责其中一个环节。OK，以上这句话的潜在前提是，你是大公司，或者你是想做大做强的公司，否者请不要使用流水线，请使用”全栈方式”开个小加工厂也是可以的。 之前写全栈时感觉自己将手握前后两端，所向披靡，谁不知人的精力是有限的，结果一切都做的皮毛。随着年龄增长，技术人员需要成为某一个领域的专拣并深入进去，当你想成为专家时，请不要考虑全栈，我想没有一个技术领域的专家投身于全栈开发。前端后端分离，开发职位细分是一个高效团队的基础。如果你在一个开发职位细分的团队，我想你很幸运，同时请把专长领域外的开发当作乐趣吧。 请轻易不要和我说全栈开发，不是不想做，是我做不到。 补充 Addition写这个文章之后的一天看到此篇外文，感觉不谋而合，推荐一下：Full-stack developers are in fact stuck at mid-level. Spare yourself from suffering – don’t go down that path]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[All You Need To Know For Migrating To Java 11]]></title>
    <url>%2F2019%2F01%2F06%2Fjava-11-migration-guide%2F</url>
    <content type="text"><![CDATA[前言首先声明，此文内容大多为译文，并非原创原文地址：All You Need To Know For Migrating To Java 11并非逐句对应翻译，只对关键内容进行翻译，如有问题请指正，感谢！ 翻译此文章的初衷源于我刚刚第一次搭建了基于Java 11的spring boot工程，遇到了一些包的缺失导致的问题，当然这些问题在Java 8时是不会出现的另外，Java 8的生命周期已经进入尾声，开发者必然面临切换到Java 11的局面，所以在搜索相关信息看到了这个文章。我将尝试翻译此文章，也让自己有更为深入的理解 正文Java 11 早在2018年9月25日发布（原文在当日发表）它标志着Java生态系统重大转变的结束（Java 9 &amp; 10都是这个过程的中间态）Java 11是LTS（Long Term Support）版本，伴随着从Java 8迁移到模块化灵活的JDK和6个月release迭代周期在作者看来，我们进入了新纪元，我们需要遵循新的Java规则，很多项目需要考虑从Java 8 迁移到Java 11。此文章将告诉你所有你需要知道的关于从Java 8迁移到Java 11 此外列出Java 11的新特性链接： New HTTP2 Client Reactive Scripting Eleven Hidden Gems 请注意，我们将在这里讨论迁移，并不是模块化（modularization），Java 11并不要求一定要模块化，那是一个独立步骤，所以这里没有创建模块 我们先从发布周期，授权方式和支持说起，最后讲解如何克服常见的4个阻碍，做过Java 9 迁移的人可能已经熟悉其中大部分内容。 发布和授权发布周期貌似没有什么，但是这是Oracle JDK商业内容的组成部分，并且相比技术迁移的挑战，公开问题（Open Question）的长期支持可能将对你的项目带来更多的影响。 发布周期频率 每六个月，发布一个新的主版本，即每年的三月和九月 每个主版本将有两个小版本更新，在每个主版本发布后的一或四个月后 （相比之前Java语言迭代发展缓慢，现在可以看出Java进入了快速发展的时代，展示其顽强的生命力，可以感觉它将继续保持语言霸主的地位） OpenJDK是新的默认版本（这个我之前的一个文章有所简单涉及，这次说更清楚些）2018年9月之前，Oracle JDK是大家使用的版本，我们一般会认为其功能更为丰富，更加稳定和高效，虽然事实并不一定（OpenJDK其实也表现的不错）。所以大多数人都是选在Oracle JDK，OpenJDK很少使用，但这一情况将在Java 11将改变。Oracle努力将Oracle JDK 11 和 OpenJDK 11 在技术上一样（OpenJDK和Oracle JDK在历史上有过不少的差异，某些时候，其实两个社区是在各自发展，虽然这段历史我可能说不清楚，但之前遇到过版本差异带来的问题），所以现在两个版本的差异只有授权文件了。Oracle期望通过将其JDK商业化方式，推动开发者进入OpenJDK。你可以使用Oracle JDK进行开发和测试，但如果没有授权文件是不可以用于产品中的。结果就是，OpenJDK将成为默认值，同时拥有全部的特性集合、主要性能以及免费的license（GPL+CE）以后可能会出现，Oracle和OpenJDK自定义厂商，都在销售他们长期支持。 长期支持 Long-Term Support首先说 Oracle JDK 和 OpenJDK，6个月内会更新两个小版本，六个月后呢？如果你还想使用Java 11呢？（下一个长期支持版本是Java 17，Oracle计划每三年释放一个新的LTS版本）怎么获得安全或修复补丁呢？两个选择： 向某人（Oracle或其他供应商）购买商业支持 期待OpenJDK有免费的支持 关于商业支持，目前可以想到的提供LTS服务的供应商有： Oracle IBM RedHat Azul （这样看，oracle不是为了自己收费哦，而是重新定义了Java世界的商业规则，你可能觉得不爽，但是这些vendor都乐在其中呢，这样来看不是一件坏事，良好的商业模式是支持Java发展的动力） 那么OpenJDK呢？根据社区讨论的邮件来看，建议对应相同的版本，将有4年左右的长期公开升级支持(Oracle Java 11 主支持要到2023年，扩展支持可到2026年，这样看，OpenJDK社区支持可以到2022年，也还不错，现在是否定下来这样执行还需进一步考证)最有可能，每一个LTS版本将有一个专属的升级负责人，例如Java 11可能由Red Hat负责。这些都是针对源码，那么我们哪里可以获得二进制文件（Binaries）呢？AdoptOpenJDK将持续生成不同平台的OpenJDK版本总结，我们可以获得免费的OpenJDK，由Java社区知名企业共同维护，并通过AdoptOpenJDK持续更新，这非常棒！ 关于Amazon Corretto财大气粗的Amazon宣布进入OpenJDK供应商行列，并发布了Corretto，并提供的长期免费的服务（目前，它只放出了Java 8，Java 11预计4月放出），关键信息如下： 基于OpenJDK，添加亚马逊实现的安全、性能、稳定、bug等修复 支持Linux Mac OS Windows 免费使用，GPL+CE授权（这就是个”搅局者”说好的供应商可以自己定制，然后买服务的你怎么不按套路出牌呢？答：有钱任性） 长期支持Java 8 到2023 长期支持Java 11 到2024 季度更新和不定期的紧急更新 参考其对OpenJDK的贡献，Amazon从2017年开始为OpenJDK贡献，所以其很可能将其Corretto的更新到OpenJDK中，这样大家就可以都使用了（好人做到底啦，贡献出来吧）。如果没有，自己看Corretto的源码，自己搞合并吧。简单说，Amazon会合并Oracle的补丁到其Corretto分支上，即使他们没有这么做，我们自己做也不难。这样使得免费的长期支持，社区驱动OpenJDK11更可行，非常酷～ 准备你的迁移（简化翻译以下内容）好了，我们准备迁移 长痛还是短痛？建议短痛： 不要建立长期合并分支，直接在开发分支尝试Java 11，避免不要的合并冲突 配置的你的持续集成服务器，普通编译一次，Java 11编译一次 学习配置编译工具特殊配置，添加新Java版本支持 版本特殊化配置尽可能的小，更新依赖好于在命令行中添加参数 更新所有开发工具建议更新： IntelliJ IDEA：2018.2以上 Eclipse：Photon 4.9RC2 with Java 11 plugin以上 Maven：3.5.0以上 compiler plugin: 3.8.0 surefire and failsafe: 2.22.0 gradle 4.10.2以上 所有操作字节码的包需要更行，因为Java版本变动，字节码的Level会每6个月更新一次 ASM Byte Buddy cglib Javassist Spring Hibernate Mockito 注意此方面的错误，例如升级Hibernate： 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;!-- LOOK OUT: YOU SHOULD USE A NEWER VERSION! --&gt; &lt;version&gt;5.2.12.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;!-- update Hibernate dependency on Javassist from 3.20.0 to 3.23.1 for Java 11 compatibility --&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.23.1-GA&lt;/version&gt;&lt;/dependency&gt; 如果不行，那就要深入问题，查找其他原因 关于模块系统就一个原则，Java 9以后，你并不需要模块化，所以该怎么组织package就怎么组织 开始迁移准备就绪，看看Java 11都会遇到什么，然后怎么解决。 未完待续……]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Modeling & NoSQL]]></title>
    <url>%2F2018%2F12%2F08%2FModeling-NoSQL%2F</url>
    <content type="text"><![CDATA[建模与NoSQL，这一切源于最近对商品建模的思考。场景，当你有很多产品，他们有不同的属性，并且差异较大，今后新增产品的属性又不确定，那么你的数据应该如何存储，如何建模呢？ Modeling商品数据的建模方式，其实我们平时经常使用，并不少见，但大多时可能只是模仿使用，并没有对其进行深入思考或整理归纳。直观的数据库建模方式就是通过一张商品表对其进行记录，也是我们最常见的行建模方式（Row Modeling）。稍微优点开发经验的朋友理解会意识到，这样的实体对象entity对应一张数据表的方式，不能很好满足我们需要面对的场景。其不适应将表现为： 属性差异过大，造成表字段数量跟随产品类别变化，并且巨大 属性差异过大，造成数据稀疏，表存储空间浪费 今后新增常品，表结构需要调整非常不灵活等等，就不一一列举了，这个思路估计连当今大学毕业设计的同学都不会犯的错误。那么应该怎么做，开发者一般会想到字段拆分，表关联方式处理。那么有什么规范可以遵循吗？答案是：有的，EAV（Entity Attribute Value）方式。他把一个实体拆成三部分，进行建模： Entity 实体，即事物本身，也就是商品 Attribute 属性，将事物所拥有的属性 Value 值，商品的具体属性对应的值简单说，这样形成了，多张关联的数据表，维护商品信息，并实现灵活调整。 这样做的坏处是什么？建模上满足了我们的场景需求，但在其他方面有不如意的地方，主要表现在： 数据表多，数据结构复杂，维护繁琐 查询语句复杂，严重影响查询性能 实际数据使用时，需要大量行列转换操作，可能需要响应试图结构支撑，是CPU密集型操作，对数据库压力大 怎么解决上面的问题，有些朋友可能第一时间想到的是NoSQL，让我们看看他们适合不？ NoSQL说NoSQL是否合适，需要先了解NoSQL的分类参考网上常见分类有四种，如下： 键值存储数据库 相关产品：Redis、Riak、SimpleDB、Chordless、Scalaris、Memcached 应用：内容缓存 优点：扩展性好、灵活性好、大量写操作时性能高 缺点：无法存储结构化信息、条件查询效率较低 列存储数据库 相关产品：BigTable、HBase、Cassandra、HadoopDB、GreenPlum、PNUTS 应用：分布式数据存储与管理 优点：查找速度快、可扩展性强、容易进行分布式扩展、复杂性低 缺点：功能相对局限 文档数据库 相关产品：MongoDB、CouchDB、ThruDB、CloudKit、Perservere、Jackrabbit 应用：存储、索引并管理面向文档的数据或者类似的半结构化数据 优点：性能好、灵活性高、复杂性低、数据结构灵活 缺点：缺乏统一的查询语言 图形数据库 相关产品：Neo4J、OrientDB、InfoGrid、GraphDB 应用：大量复杂、互连接、低结构化的图结构场合，如社交网络、推荐系统等 优点：灵活性高、支持复杂的图形算法、可用于构建复杂的关系图谱 缺点：复杂性高、只能支持一定的数据规模 所以，如果使用NoSQL存储多变的字段数据内容，第一优选就是文档数据库，甚至可以考虑使用ElasticSearch来完成更为复杂的搜索需求。这样的方法是否合理呢？ NoSQL 方案问题增加系统开发复杂度，需要同时操纵两种不同类型的数据库。毕竟原有的业务数据还需要在关系型数据库中保存，同时无法合理关系化的字段数据将存入NoSQL数据库中。 需要考虑两个数据库保证数据一致性问题 数据使用时需要考虑合理的查询方式，拼接数据 简单说数据使用和维护的相关系统实现架构都需要有较好的设计和开发支撑，系统复杂度大，运营维护成本高。同时不否认，这种方式也有其实际应用价值和优势，也是一种常见的处理方式。 那有没有其他方案？ JSON 类型数据引入JSON类型也逐步成为主流，也逐渐成熟。记得最早是PostgreSQL 9.3的一次创新型实验，之后就是MySQL 5.7也添加了相应的支持，Oracle 12cr1 依MySQL为例，简单看一下其功能 创建表 1CREATE TABLE t_json(id INT PRIMARY KEY, sname VARCHAR(20) , info JSON); 插入数据 123456-- 插入含有json数组的记录INSERT INTO t_json(id,sname,info) VALUES( 1, 'name1', JSON_ARRAY(1, "abc", NULL, TRUE, CURTIME()));-- 插入含有json对象的记录INSERT INTO t_json(id,sname,info) VALUES( 2, 'name2', JSON_OBJECT("age", 20, "time", now()));INSERT INTO t_json(id,sname,info) VALUES( 3, 'name3', '&#123;"age":20, "time":"2018-07-14 10:52:00"&#125;'); 12345-- 查询记录SELECT sname,JSON_EXTRACT(info,'$.age') FROM t_json;SELECT sname,info-&gt;'$.age' FROM t_json;-- 查询keySELECT id,json_keys(info) FROM t_json; 所以，关系库中的JSON类型是可以比较理想的满足我们使用场景，既兼顾了原有业务数据也保证了数据的灵活性，同时维护和使用技术环境统一，降低系统复杂度。缺点，性能略有损失，代码处理略有复杂。针对JSON数据内容也是可以建立索引的，提升查询速度，这个的使用也许合理设计。 总结文章从第一天建立到今天（1-4）补完，经历快一个月。这一个月本人也经历了很多，同时，做了一个从业以来最任性的决定，至于结果如何，那就看自己的努力了。 新的一年开始，感谢我接触过的所有人，感谢你们的帮助。希望个人今后可以走的更好。祝大家安康！ 参考EAV 模型NoSQL 分类数据库 JSON 类型]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API Gateway]]></title>
    <url>%2F2018%2F11%2F20%2Fapi-gateway%2F</url>
    <content type="text"><![CDATA[说一说API Gateway，一切服务的入口。也称其为API Management，这是一个比我之前想象还要大的系统，这篇文章我尝试做一些总结。下面提到的API Gateway 和 API Management 将作为等同名词，除非我特殊说明。 什么是API Gateway？它主要做什么事情，提供什么功能简单说就是将后面的微服务的API统一暴露出来的网关的就是API Gateway。他应具备一下能力： 微服务API路由功能自定义路由规则，暴露出访问路径，并可以通过访问路径路由到对应的后端服务中 用户验证及鉴权通过对Request请求中相关信息的判断，鉴别用户和其访问权限 API版本控制和发布API发布、上线、测试、停用已经不同版本的控制 API信息维护这个功能类似于swagger这样的功能，展示接口调用信息 API访问流量控制对API访问进行流量、测试、频率等方面的控制 API调用监控及报警监控API调用执行情况，例如调用时长、是否有异常，并对敏感信息进行报警 参数校验及转换对Request请求中的参数进行校验和转换，防止注入攻击等 当然还有其他功能，这里不一一列举了。 已知的云服务 名称 apigee AWS API 网关 阿里云API网关 腾讯云API网关 网址 apigee.com amazonaws-china.com /cn/api-gateway www.aliyun.com /product/apigateway cloud.tencent.com /product/apigateway 公司 Google Amazon Aliyun Tencent API生命周期管理 Y Y Y Y API身份验证 Y Y Y Y 权限控制 Y Y Y Y 算法签名、SSL Y Y Y Y 流量控制 Y Y Y Y IP访问控制 N Y Y N CORS Y Y Y Y 请求参数校验 Unknow Y Y N 请求参数转换 Unknow Y Y Y API监控 Y Y Y Y 异常报警 Y Y Y N SDK生成 Y Y Y N Mock接口 Y Y Y Y 以上功能总结可能存在错误，可能有些是我没有找到的。同时各个厂商的功能今后可能趋同，目前看AWS和Ali做的最好。 API Gateway有哪些开源框架？目前看到的比较理想的开源框架有：Kong、WSO2、TYK、Spring Cloud Gateway。最近主要研究了前两个，简单说明各自优缺点 Kong使用最为广泛，开源协议Apache License 2.0，有付费商业版，开源版和付费版主要区别在于部分企业版插件 优点： 性能非常出色，基于Nginx Openresty实现，源码简洁 插件功能比较完善，支持自定义插件扩展，灵活易用，基本满足常见场景 支持Docker，K8S等应用场景，部署灵活 官方文档丰富，阐述清楚，上手快 缺点： Lua语言开发，需要Linux编译环境，二次开发环境有特殊要求 已有开源插件中并未覆盖API网关全部功能， WSO2功能十分强大，开源协议Apache License 2.0，提供云服务和商业support支持服务 优点： 功能十分齐全，并提供配套组件项目 Java开发，开发环境普及度高 支持Docker K8S等应用场景，部署灵活 缺点： 源码过于庞大，难以消化，基本都是自定义jar包 官方公开文档信息不全，没有付费Support难以使用（我觉得是对方故意的） ##选型结论最终，团队选了Kong作为实现基础，基于其插件进行二次开发。 ##后记Lua的开发确实不太令人舒服，如果团队中没有人使用过Lua开发还是建议不要轻易使用。Zuul的开发还是更适合Java团队使用，找时间可以看看zuul2的性能是否有所改善。 P.S. 由于刚刚换了工作，所以最近一段时间没有更新文章，稍后会慢慢恢复。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Consul的多实例注册问题]]></title>
    <url>%2F2018%2F11%2F09%2Fconsul%2F</url>
    <content type="text"><![CDATA[公司终于要重构一个非常古老的项目了（之前我建议了好多次，也讨论了好多次，这次终于动工了），将其按照微服务方式搭建，采用spring cloud框架（之前已经在其它项目中使用了很久）很期待此项目可以顺利实现，可以支撑未来的业务发展，然而这一次稍微来的晚了一些，我就要离开了。走之前我还是站好最后一班岗，把新版工程的微服务架构搭建一下，并实现统一gateway入口路由和oauth认证逻辑还有Member用户中心微服务中必要的接口，算是遗产了。按照我的习惯，只要是全新的项目，我将尽可能更新之前使用到的技术。由于之前我们使用的是Eureka作为注册服务，而它在2.0宣布闭源，这个对今后会带来什么影响未知，所以我决定将新版工程架构注册服务迁移到Consul。这不就遇到问题了…… 问题描述我有一个Member用户中心服务，当我在不同主机（不同ip地址）上运行两个Member微服务时，Consul中心只能看到一个服务实例。第一反应，What！？ 这个和我想象的完全不一样啊，这应该是默认功能啊，服务的多节点哪里去了！？如图：我运行了两个实例，但只能看见一个 我这里的consul用的是1.3版本 问题原因Consul团队具体怎么考虑这个实例名称生成规则的，我不是很清楚，但是问题就是因为它https://github.com/spring-cloud/spring-cloud-consul/issues/318一年多前开的issue竟然还没有关，问题就是instance id的默认组成规则是 application name - port没有ip地址，所以当我启动Member服务时，虽然在不同主机上，但是端口相同，所以instance id是一样一样的😂所以，我们只能看到最后启动的那个实例虽然下面回复中，中国朋友（推断）给出了明确的问题所在和建议的解决方法，然而Consul开发团队还是继续坚持他们的想法（或是spring cloud discovery包没有及时更新！？，issue没有关可能consul团队问题更多一些，人家spring团队也只是整合而已啦），额～～～为什么不改，没有理解 解决办法程序员DD给出了解决办法顺便提及一句，程序员DD非常不错，值得关注 随机端口方式我就不说了，这个不可取，我没有用。 直接final way，重新实现ConsulServiceRegistry 1234567891011121314151617181920/** * 调整consul服务注册实例名称 * * @author gino * Created on 2018/11/9 */@Configurationpublic class MyConsulServiceRegistry extends ConsulServiceRegistry &#123; public MyConsulServiceRegistry(ConsulClient client, ConsulDiscoveryProperties properties, TtlScheduler ttlScheduler, HeartbeatProperties heartbeatProperties) &#123; super(client, properties, ttlScheduler, heartbeatProperties); &#125; @Override public void register(ConsulRegistration reg) &#123; reg.getService().setId(reg.getService().getName() + "-" + reg.getService().getAddress() + "-" + reg.getService().getPort()); super.register(reg); &#125;&#125; 没有什么好解释的，在此启动就有两个服务了，如图两个服务，正常注册上了，红色区域就是我们要解决的问题最终结果。 总结除了Consul中的一些小改变，其实每次Spring Cloud的版本升级（当前使用的Greenwich.M1）都会这样那样的问题，我们需要慢慢踩雷，慢慢成长。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minsky Moment]]></title>
    <url>%2F2018%2F11%2F05%2Fminsky%2F</url>
    <content type="text"><![CDATA[明斯基时刻，最近刚刚了解到这个词，但听说已经火了一年了，我也算是后知后觉了。以下内容摘自百度百科和部分自身修改 基本定义明斯基时刻（Minsky Moment）是指美国经济学家海曼·明斯基 （Hyman Minsky）所描述的时刻，即资产价值崩溃的时刻。明斯基观点主要是经济长时期稳定可能导致债务增加、杠杆比率上升，进而从内部滋生爆发金融危机和陷入漫长去杠杆化周期的风险 简单说明斯基时刻表示的是市场繁荣与衰退之间的转折点。明斯基的观点简单明了：好日子的时候，投资者敢于冒险；好日子的时间越长，投资者冒险越多，直到过度冒险。一步一步地，投资者会到达一个临界点上，其资产所产生的现金不再足以偿付他们用来获得资产所举的债务。投机性资产的损失促使放贷者收回其贷款。“从而导致资产价值的崩溃。” 过程以现金流作为依据，海曼·明斯基将市场上的金融行为主体分为三类，其中风险最大的主体是高杠杆的银行和高赤字的政府部门。海曼·明斯基认为，资本主义经济追逐利润的本性和金融资本家天生的短期行为导致了资本主义金融业的不稳定 ，它是无法根除的，只要存在商业周期，金融业的内在不稳定就必然演化为金融危机，并进一步将整体经济拉向大危机的深渊 。在商业周期的上升阶段，内在危机会被经济增长所掩盖，但是一旦经济步入停滞甚至下降周期，矛盾便会迅速激化，高风险 的金融主体就会以变卖资产来偿还债务，也就是后来的学者所总结的明斯基时刻。 三阶段 第一阶段，投资者们负担少量负债，偿还其资本与利息支出均无问题。 第二阶段，他们扩展其金融规模，以致只能负担利息支出。 第三阶段，即旁氏骗局，他们的债务水平要求不断上涨的价格水平才能安然度日。 主要观点 在资本驱动的发展模式下，现代社会的金融周期和经济周期是重合的，信贷的扩张、收缩和经济的繁荣、衰退，是相互作用和加强的 信贷危机发生的临界点，也就是明斯基时刻，是信贷生产，消费和预期共同作用下的结果，它不以人的意志为转移 政府的逆周期宏观调控可以减轻这种周期的波动 摘自：香帅的北大金融学。 很巧，刚刚写了这个文章，香帅就发布一个关于此话题的节目 理论局限性明斯基的分析仅仅集中在“排他性的金融市场”，并没有很好地解释经济和金融之间的关系。明斯基的金融不稳定假设涉及的几乎完全是短期的周期性现象，只是一个“明斯基时刻”，而不是作为一种发展趋势。这个事实使他的分析更易被主流理论家们所接受——他们最关心的是证明经济会在政府的轻推下迅速反弹。 总结目前，我对此理解还停留在表面上。你认为我们在第几阶段了？ ……]]></content>
      <categories>
        <category>business</category>
      </categories>
      <tags>
        <tag>financial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes in Mac OSX 初探]]></title>
    <url>%2F2018%2F10%2F31%2Fkubernetes-in-mac-osx%2F</url>
    <content type="text"><![CDATA[折腾了许久，终于在我的苹果系统上安装上了kubernetes（k8s），可以开始实战了。 由于国内网络限制原因，你想安装Google资源下的k8s十分困难，你需要VPN，比较简单直接。开始在Ubuntu Server上折腾了一下，有点麻烦，而我主要是想体会一下使用效果，最后还是决定采用Mac OSX下Docker中的k8s试试，当然它的安装也需要VPN工具。 通过Docker内部自带的k8s安装，简单方便，不需要考虑minikube和virtual box或者其它虚拟化驱动（这里就直接跳过了，毕竟我也没有深入研究）安装后的k8s是但节点环境，所以默写细节功能与集群有差别，这个我需要慢慢体会。 启动Docker 下的 Kubernetes很简单，如图所示，enable apply running 查看基本信息查看版本，得到如下信息 12345➜ ~ kubectl versionClient Version: version.Info&#123;Major:"1", Minor:"10", GitVersion:"v1.10.3", GitCommit:"2bba0127d85d5a46ab4b778548be28623b32d0b0", GitTreeState:"clean", BuildDate:"2018-05-21T09:17:39Z", GoVersion:"go1.9.3", Compiler:"gc", Platform:"darwin/amd64"&#125;Server Version: version.Info&#123;Major:"1", Minor:"10", GitVersion:"v1.10.3", GitCommit:"2bba0127d85d5a46ab4b778548be28623b32d0b0", GitTreeState:"clean", BuildDate:"2018-05-21T09:05:37Z", GoVersion:"go1.9.3", Compiler:"gc", Platform:"linux/amd64"&#125;➜ ~ kubectl config current-contextdocker-for-desktop 分别为Client 和 Server版本，其中Platform，client是darwin/amd64，Server是linux/amd64 123456➜ ~ kubectl cluster-infoKubernetes master is running at https://localhost:6443KubeDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy➜ ~ kubectl get nodesNAME STATUS ROLES AGE VERSIONdocker-for-desktop Ready master 20h v1.10.3 本机只有一个节点 Dashboard管理上，目前我看到两种方式 通过kubectl命令的方式进行管理，主要维护方式 通过Dashboard进行管理， 主要是查看方式 安装Dashboard： 1kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml 查看Dashboard所在namespace中pod信息，需要指明namespace，否则查看的是default namespace下的pods： 123456789➜ ~ kubectl get pods --namespace=kube-systemNAME READY STATUS RESTARTS AGEetcd-docker-for-desktop 1/1 Running 5 1dkube-apiserver-docker-for-desktop 1/1 Running 5 1dkube-controller-manager-docker-for-desktop 1/1 Running 3 1dkube-dns-86f4d74b45-r9w7b 3/3 Running 0 1dkube-proxy-mzrx2 1/1 Running 0 1dkube-scheduler-docker-for-desktop 1/1 Running 3 1dkubernetes-dashboard-7b9c7bc8c9-zkgzk 1/1 Running 2 1d 开启proxy，开始访问dashboard服务 1➜ ~ kubectl proxy 浏览器打开：http://127.0.0.1:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy 或者使用kubctl prot-forward 将dashboard pod运行的端口暴露出来进行访问 1➜ ~ kubectl port-forward pods/kubernetes-dashboard-7b9c7bc8c9-zkgzk 8443:8443 --namespace kube-system 浏览器访问：https://127.0.0.1:8443，注意chrome提示你证书安全问题，直接unsafe方式访问吧 选择跳过，具体可以做什么，我还没有弄清楚，如果稍后了解，我再更新 我们可以看到纵览页面 这里截图是，我已经尝试部署了nginx pod，所以多了一些信息 用nginx部署 实战一下可以通过以下指令，部署一个pod 12345➜ ~ kubectl run hello-nginx --image=nginx --port=80➜ ~ kubectl get deploymentNAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEhello-nginx 1 1 1 1 1d 说到这里就有三个基本概念不得不说了，通过系统页面中给出的连接，我们针对nginx这个部署，看到以下这三个不同的内容这里我的理解尚浅，可能有描述不准确地方，欢迎告知 deployment 用于管理 replica sets 和 pods，您只需要在 Deployment 中描述您想要的目标状态是什么，Deployment controller 就会帮您将 Pod 和ReplicaSet 的实际状态改变到您的目标状态。 replica set 副本，用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收。![](/images/post/20181031/replica set.png) pod 是kubernetes中你可以创建和部署的最小也是最简的单位。一个Pod代表着集群中运行的一个进程。pod里面饱含着docker的容器12➜ ~ docker ps | grep nginx66f968b67cf5 nginx "nginx -g 'daemon of…" 7 hours ago Up 7 hours k8s_hello-nginx_hello-nginx-6584d58b4c-gvk5b_default_f21fbf54-dce9-11e8-b679-025000000001_0 请注意这里的6584d58b4c-gvk5b，和对应的pod的名字中的编号一致 好了，这样几个基本概念就都连起来了。 怎么可以访问到这个nginx服务呢，这就需要引入service概念，我们将pod运行的实例暴露成服务 1➜ ~ kubectl expose deployment hello-nginx --type=NodePort --name=hello-nginx-service 命令行可以通过以下指令查看 1234➜ ~ kubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEhello-nginx-service NodePort 10.99.167.149 &lt;none&gt; 8010:32340/TCP 1mkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 2d 问题，是我并没有成功访问localhost:32340，这个我需要再看看。 安装 istio根据官方文档，我们可以很快部署istio podshttps://istio.io/docs/setup/kubernetes/quick-start/ 下载istio文件后，在其目录下运行 1kubectl apply -f install/kubernetes/helm/istio/templates/crds.yaml 这部分我还需要继续实验下去，找时间继续更新。 总结kubernetes 的复杂程度超出了我对其的猜测，里面的知识点很多，需要花很多精力去深入进去，初步感觉还是挺有意思的。 参考网站：wilbeibi jimmysong]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 11 License]]></title>
    <url>%2F2018%2F10%2F31%2Fjava-11-license%2F</url>
    <content type="text"><![CDATA[晴天我的霹雳～～～～ 今天在MacOS下玩Kubernets，无意间发现Java 11的资源包变成的OpenJDK，去找Oracle版本时看到这个说明： Oracle’s Java 11 trap - Use OpenJDK instead! 文章重点就是，Java 11的License是商业授权，用于商业活动时，你是要付费的，不是免费的。 Oracle License原文可以参见这里：Oracle Technology Network License Agreement for Oracle Java SE Further, You may not: use the Programs for any data processing or any commercial, production, or internal business purposes other than developing, testing, prototyping, and demonstrating your Application; 就是这句话。 根据上文博主的说法，之前的license肯定都是免费的（我之前没有特别留意过），现在商业用途竟然需要收费了。 现在Google搜索引擎中搜索Java 11，可以看到Oracle 维护的open jdk 版本了。是的，它在维护openjdk版本地址在这里：https://jdk.java.net/11/ 当然文中博主还给出了其它的编译版本，https://adoptopenjdk.net 使用Java的小伙伴们，升级到Java11那是必然的，毕竟Java8支持终止时间已经明确了，只有Java11是最近的一个LTS版本然而，如果你还想免费用的话，请使用openjdk，别到头来，你开发了商业软件，最后要支付一大笔钱给Oracle钱多的土豪和拿Java写着玩（非商业软件）的人士可以忽略。 顺便说一句：作为国内的程序员，希望大家重视商业授权方式，开源 不等于 免费，一个是代码维护方式（开源协议也很多，请自行查找），一个是商业授权方式。因为，如果你想走的更远，你需要在规则体系之内，良好的意识也需要慢慢培养。共勉～]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Registration and Discovery - Spring]]></title>
    <url>%2F2018%2F10%2F29%2Fregister-discovery%2F</url>
    <content type="text"><![CDATA[关于Spring Cloud支持的注册发现服务，一直想了解一下对比情况，今天无意间发现这个对比文章，简单直接，可以给你一个直观的初步认识。转载原地址：服务发现比较:Consul vs Zookeeper vs Etcd vs Eureka这里仅贴出总结表格，稍作调整。其它内容请参见原文 Feature consul zookeeper etcd euerka 服务健康检查 服务状态，内存，硬盘等 (弱)长连接，keepalive 连接心跳 可配支持 多数据中心 支持 — — — KV存储服务 支持 支持 支持 — 一致性 raft zab raft — CAP ca cp cp ap 使用接口(多语言能力) 支持http和dns 客户端 http/grpc http（sidecar） Watch支持 全量/支持long polling 支持 支持 long polling 支持 long polling/大部分增量 自身监控 metrics — metrics metrics 安全 acl/https acl https支持（弱） — Spring Cloud集成 已支持 已支持 已支持 已支持，2.0闭源 感谢原作者的分享，并贴出与其文中一处不一样的观点，zookeeper的一致性协议不是Paxos，应该是ZAB。此观点依据：The core consensus algorithm of ZooKeeper is not Paxos 另外，euerka宣布2.0闭源后，目前来看Consul是替代euerka一个不错的方案。 CAP 简单解释 一致性(Consistency) (所有节点在同一时间具有相同的数据，客户端请求到同样的数据结果) 可用性(Availability) (保证每个请求不管成功或者失败都有响应) 分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作) CAP 不可能全都同时满足，这个已经被证明过了，这里先记住结论吧，具体解释网上文章很多。 Raft 演示相比Paxos，raft更容易被人理解和接受，看一下这个演示动画吧，简单直观。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>CAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Five Events of Scrum]]></title>
    <url>%2F2018%2F10%2F28%2Ffive-events%2F</url>
    <content type="text"><![CDATA[Scrum一个非常好的项目管理方式（方法论），我十分喜欢，但是，项目中使用需要很多客观条件支持，例如公司环境，队员素质等等。无论怎样，个人十分推荐在项目中尝试该管理方式。虽然，我不是Scrum Master（本人只有PMP证书），但是我一直对此深入学习，并尽可能多的将其应用到实际项目中。 今天我说一下Scrum中的五个事件 The Sprint 冲刺 一个敏捷迭代 Sprint Planning 敏捷迭代计划 Daily Scrum 每日Scrum Sprint Review 敏捷迭代评审 Sprint Retrospective 敏捷迭代回顾 The Sprint英文直译就是冲刺，其实我们可以将项目划分成多个sprint（冲刺），从而依高效、快速的方式完成整个项目。一个sprint周期一般为1个月（常见可以为2～4周）最终释放产品的增量（increment），在项目执行过程中，一个spring接着另一个sprintsprint过程中包括什么？ sprint包括下面四个事件，同时还包括具体开发工作。 sprint可以取消吗？ 当然可以，但只有产品经理有权限取消（终止）sprint，当然他要与必要的团队成员进行沟通。但是，sprint一般不会遇到取消，因为取消一个sprint通常是因为目标已经过时，但是sprint本身周期就很短，目的就是为了更好面对改变，所以一般不会遇到这个场景另外，一个sprint的取消将对团队和项目都有很不好的影响，甚至需要重新评估产品的Backlog，所以这个应避免出现。 在sprint中，我们应该 对sprint目标实现有影响的改变都不应该接受，实际上通常做法是freeze backlog后就不进行修改了，但是现在也有使用弹性冻结的思路 质量目标不能下降，降低sprint最终目标质量 随着项目的深入，产品经理和开发团队可能需要重新商讨项目范围，可能是因为任务难度超出了之前的预期。这也是弹性冻结的原因 Sprint Planning冲刺计划，或者是一个迭代周期的计划，通常表现形式为敏捷迭代计划会议，一般需要4个小时（一个小时对应一周）制定一个迭代周期内的相关工作，根据product backlog中的任务优先级形成sprint backlog。sprint planning 主要回答两个问题： 此sprint结束时将交付什么（increment）？ 为了正常交付，都需要做什么工作（backlog）？同时，也要明确，迭代时间、后续工作时间表、团队成员等会议一般需要包括： Scrum Master 宣布迭代时间表 阐明、更新product backlog，对业务的价值和优先级，并达成共识 选出并确定sprint backlog，团队共识迭代目标 拆解sprint backlog形成具体任务，每个任务应该小于2天 任务初步分配，可以使用看板进行后续跟踪和管理 Daily Scrum每日scrum，通常表现形式为 Daily Stand-up Meeting 日站立会，一般需要15分钟目的就是为了让组内成员互相知道都在做什么，有什么问题需要解决会议一般包括： 我昨天做了什么有利于sprint目标达成的工作 今天计划做什么有助于sprint目标达成 当前工作是否遇到问题妨碍目标达成 站会的站不是必须的，但一般为站着是为了提高效率，15分钟，大家直接沟通，不要阐述或讨论详细内容。 Sprint Review冲刺评审，通常在一个sprint周期的最后一天，评审此次sprint交付成果，通常表现形式为敏捷迭代评审会议，一般需要4个小时展示此sprint阶段的成果，进行评审、检查是否达到了预期的目标，参会人员应该包括项目团队成员和利益相关者，一般又产品经理来邀请会议一般包括： 完成什么，什么没有完成，阐述增量更新 开发团队总结哪些正在往好的方向发展，哪些遇到了问题，哪些问题得到了解决 后面要实现什么，这个可以作为下一个sprint迭代计划的输入 评审项目需求、预算、时间周期等，讨论产品任务清单，是否需要调整product backlog 此会议主要是总结迭代周期内工作完成情况 Sprint Retrospective冲刺回顾，通常在一个sprint周期的结束后某的一天（在review之后，在下一个planning之前），回顾此次sprint执行过程中的问题和好的经验总结，通常表现形式为敏捷迭代回顾会议，一般需要3个小时会议一般包括： sprint周期内，人员、流程、工具等表现如何 哪些做的好，哪些今后可以提升 创建后续可以提升的计划 此活动主要是总结团队Scrum经验，便于后面做的更好。 如有有问题，应该是整个团队负责，并寻找解决方法。 先写这些，今后再总结其它关键点]]></content>
      <categories>
        <category>management</category>
      </categories>
      <tags>
        <tag>scrum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Order Type]]></title>
    <url>%2F2018%2F10%2F26%2Forder-type%2F</url>
    <content type="text"><![CDATA[今天总结一下金融交易市场中订单类型（交易指令类型） 在金融市场中有很多的订单类型，在不同的市场（地区或者交易品种）针对不通的用户（散户还是券商等）可以使用的订单类型是不同的。订单类型的不同主要看券商和交易所是否支持（也有在交易客户端实现的，个人感觉那个就不要考虑了）这里仅仅将已知的订单类型列出，进行必要的总结。 买卖方向、开仓平仓这些内容直接跳过，我就不说了哈～ 先说从价格方面都有什么类型 市价单、限价单这两个放在一起说吧，应该是最常见和常用的两种类型，无论是股票、债券交易还是衍生品交易，我都可以看到这两种类型。 市价单（Market Order）：是以当时市场价格成交的订单，不需要自己设定价格，可以使得订单快速成交。限价单（Limit Order）： 需要指定成交价格，只有达到指定价格或有更好价格时才会执行。常为默认类型 很简单，很容易了解哈，市价单的心声，我就是要买入/卖出 价格不在乎，现价单的心声是：我先准备一下，价格到位，买入/卖出在执行 止损（盈）单止损单（Stop Order）是指在订单中设置止损价格，需要输入一个指定的止损价（Stop Price），一旦股价到达所设定的止损价，将会以市价单（Market Order）的方式成交。止损单和限价单的区别是低卖高买。国内少有做空机制，所以我们常见其在价格下跌时使用，其它市场可不一定哦 限价止损（盈）单限价止损单（Stop Limit Order）是止损单和限价单的组合即需要客户输入一个指定的止损价（Stop price，触发条件）和指定的限价（Limit Price 期望成交价格），一旦股价达到设置的止损价，将以限价单的方式下单 跟踪止损（盈）单跟踪止损单（Trailing Stop order） 止损触发条件，策略升级就是不限定止损价格本身，而是可以设置止损价格和市场价格之间的差价。差价的设置可以用金额，也可以用市价的百分比表示。 注意：这里的Stop Order其实是止盈止损都可以，在中国大家习惯的将其用于止损，所以叫法也就沿用了。个人一直有个感觉，金融术语最好看英文，中文翻译过来后很多本来很直接的描述变得让人难以理解或误解，再举个例子，例如：掉期（有机会再说了），外人看来，就是什么鬼～😛 在从时间和成交方式上都有什么类型 当日有效订单Day Orders，顾名思义，就是我们下的委托只在当日有效，闭市后委托自动撤销 GTC订单一直有效订单（Good Till Cancelled）字面意思交易下单人员不主动撤销此委托将长期有效，当然经纪商（Broker）通常限制GTC的最长有效时间，毕竟长期有效这是有成本的 IOC订单立即执行否则取消订单（Immediate Or Cancel），是委托指令尽可能多的成交（一次撮合判断），不成的部分就撤单。 FOK订单立即成交否则全部取消（Fill Or Kill），是指委托指令必须立即执行否则就全部取消（一次撮合判断），即不允许部分成交。 FAK订单立即成交并撤单（Fill And Kill），可以理解为FOK和IOC的组合体，是指委托指令必须立即执行尽可能多的成交（一次撮合判断），允许部分成交。同时，可以设定最小成交数量也可以不设定最小成交数量。如果设定最小成交数量，在限定价位下达指令后，若成交的申报手数高于或等于最小成交。 AON订单全部成交否则全部取消（All Or None），是指委托指令要么全部执行，要么全部取消，但可以等一等，直到撤单 再说一个，高级指令 冰山单冰山单（Iceberg Order），我们可以将一个大的委托发出，但在交易市场行情或盘口数据中逐步释放成交量和委托数量，这种单子在实际操作场景中是有战术意义的，隐藏真实的交易规模。这个不展开说了，单独都可以写一篇博客了。 好了，目前就这些类型吧，如果后期遇到新的，我再更新。 当然，我们目前实现的订单类型也很有限。]]></content>
      <categories>
        <category>business</category>
      </categories>
      <tags>
        <tag>financial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Transaction]]></title>
    <url>%2F2018%2F10%2F25%2Ftransaction%2F</url>
    <content type="text"><![CDATA[事务，很基础的概念，但有很多细节是大家忽略的或者平时很少注意到的。这里总结一下：实验工程 （这工程的实验代码尚不完整，再更新看心情了😛） ACID先说ACID，工程里说自查度娘，还是算了吧，我还是解释一下吧，度娘不靠谱 原子性（Atomicity） 操作原子性，同一个事务中要么所有操作都执行，要么都不执行。好理解 一致性（Consistency） 一致性（经常和原子性混），原意是数据库从一个状态转换为另一个状态（完全不知所云哈？）。其实说的是写入数据必须复合数据库的相关约束，包括限制、级联、触发等（还不明白？）举个例：A外键关联B，一个事务试图插入B数据，但不插入与其关联的A记录，当然这是非法事务，它违反的就是一致性原则。 隔离性（Isolation） 隔离型决定了，是否可以避免脏读、不可重复读、幻读，这个下面来深入说明，这个也很少有人关注过 持久性（Durability） 持久性，这个强调的是commit后不要存在内存中，commit要求写入硬盘，当然也就不丢了 参考 单说隔离性隔离级别 解决脏读取、重复读、幻读 DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED。 READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。 READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。 SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 脏读 不可重复读 幻读 READ_UNCOMMITTED ✅ ✅ ✅ READ_COMMITTED ❎ ✅ ✅ REPEATABLE_READ ❎ ❎ ✅ SERIALIZABLE ❎ ❎ ❎ 脏读（Dirty Read）：A事务进行中读到了B事务尚未commit的数据 不可重复读(Fuzzy/Non-Repeatable Read) : A事务进行中第一次读取，B事务提交更新数据，A事务再次读取，数据不一致 幻读（Phantom Read）：A事务读取了M跳数据，B事务插入数据N条提交，A事务再次读取发现为M+N条 个人推断，事务隔离级别应该和数据库锁相关，不可重复读需要行级锁，而幻读需要表级锁。这个需要进步一验证 注意：这里说的都是数据库自身问题，如果在开发过程中，我们使用的ORM框架自身还有数据对象状态问题，例如：临时态、持久态、游离态。这些不正常处理可能会造成事务内操作出错。 解决程序或数据库中类似的数据冲突问题，我们需要考虑程序锁或数据库错（无论怎样性能都将受到影响，需要合理设计），或者CAS操作（性能好，但是应用场景受限），这又将是个大话题，稍后再阐述吧。 进阶阅读这个文章比我说的详细多了，pingcap团队的。 推荐阅读。 后续近期公司需要将一套老系统进行微服务拆分并重构，花了一天的时间深入梳理一下ACID BASE 和 CAP，这些概念之前虽然都看过，但是现在再看又有更为深刻的理解了，温故而知新啊这个部分内容专业、庞大又复杂，还是先推荐几篇别人的文章吧，如果可能，稍后再总结自己的想法CAP、ACID、BASE理论及NWR实践策略详解分布式服务化系统一致性的“最佳实干”]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Distributed Lock]]></title>
    <url>%2F2018%2F10%2F22%2Fdistributed-lock%2F</url>
    <content type="text"><![CDATA[分布式锁，在微服务，多服务器水平扩展以及高并发的场景下，要保证共享资源正确处理，这个锁很重要。我了解到了三种实现方式： 数据库方式，基于主键唯一性约束或行级锁实现 Zookeeper实现，基于其临时有序节点实现 Redis方式，基于setNX操作实现 三种方式各有优缺点，在恢复此博客之前我已经实现了基于Redis版本的分布式锁，现在把另外两种加以实现，并做相应的对比。 Mysql数据库方式实现分布式锁，主要用三种形式： 乐观锁，version，通过where条件中的version决定是否可以更新成功，从而获得锁 主键唯一约束方式，是否可以正常写入数据，从而获得锁 数据库自身锁 for update 来决定是否可以获得锁 这里我们不讨论乐观锁，为了和zookeeper、redis的锁做对比，这里采用使用主键唯一约束方式实现锁。 创建锁表，其中method_name需要索引并唯一，时间默认 1234567CREATE TABLE method_lock( id int PRIMARY KEY NOT NULL AUTO_INCREMENT, method_name varchar(64) NOT NULL, update_time timestamp not null default current_timestamp on update current_timestamp);CREATE UNIQUE INDEX method_lock_method_name_uindex ON method_lock (method_name); 关闭自动提交，开始手动提交，保证事务中的操作原子性 1connection.setAutoCommit(false); 获得锁，两个操作，删除超时的锁（超时自动释放机制），插入数据获得锁 123456789PreparedStatement preparedDelete = MySQLConfig.connection.prepareStatement(clearSQL);preparedDelete.setString(1, name);preparedDelete.setInt(2, 3);preparedDelete.executeUpdate();PreparedStatement preparedInsert = MySQLConfig.connection.prepareStatement(insertSQL);preparedInsert.setString(1, name);MySQLConfig.connection.commit(); 如果提交失败，进行重试，设定时间间隔和重试次数 1public static boolean getLockTimes(String name, int times, int interval) 释放锁，直接删除锁占有的记录 1234PreparedStatement preparedDelete = MySQLConfig.connection.prepareStatement(deleteSQL);preparedDelete.setString(1, name);preparedDelete.executeUpdate();MySQLConfig.connection.commit(); Zookeeper不重复造轮子了，轮子原理简单说一下吧，两种实现方式： 固定节点，利用文件名称唯一性，谁可以创建create指令该节点，谁就获得锁，类似redis中的获取锁操作，删除节点释放锁，其它watch该节点 利用zookeeper中临时有序节点，尝试获得锁，如果当前线程申请到的节点序号为最小，则获得锁，否则监听前一个序号等待状态改变，然后再次判断。 建议大家，如果有轮子就不要自己造了，因为绝大多数情况下，我们造的不如已有的轮子。所以，实验使用成熟的CuratorFramework，创建InterProcessMutex锁对象 通过acquire尝试获得锁，其中3s为可以接受的尝试获得锁的时间，如果太短，可能资源竞争激烈导致获得不到锁，而返回false，所以考虑了重试机制。 1mutex.acquire(3, TimeUnit.SECONDS); 释放锁，事务处理完毕后，需要释放锁，最好判断一下，是不是当前线程拥有这个锁，然后尝试释放。 1234if (mutex.isOwnedByCurrentThread()) &#123; mutex.release(); log.info("release lock....");&#125; 如果按照网上原理介绍来看，其判断是自增序号的最小值为获得锁，那么其应该是是一个公平锁，这一点我需要再进一步验证一下。 RedisRedis分布式锁，redis官网有相应的文章阐述，这里相当于模仿着造了一个轮子 首先实现一个redis实例即单节点的例子，这个是基础。通过多线程方式模拟测试，实际应用不应该是多线程环境，否则使用线程同步相关技术就好了。其次，初步实现了RedLock方式，用于多个Redis节点，增强其稳定性。但实际使用可能还是单节点比较多，需要考虑锁失效的弥补方式。 这里的set方法是关键，其保证了判断是否存在以及设置锁值和有效时间一系列操作的原子性，否则这个分布式锁的实现是不成立的。 123456String res = resource.set(lockKey, uuid, "NX", "PX", keyExpire);if ("OK".equals(res)) &#123; resource.close(); log.info("Get lock, uuid: &#123;&#125;", uuid); return uuid;&#125; 设置成功，则获得锁，否则失败。其中设置的值为uuid随机数，所以这个理论上是非公平锁 释放锁，即删除值，这是需要watch这个值，并在事务内将其删除 12345678910111213resource.watch(lockKey);if (uuid.equals(resource.get(lockKey))) &#123; Transaction multi = resource.multi(); Response&lt;Long&gt; del = multi.del(lockKey); multi.exec(); if (del.get() == 1) &#123; log.info("Release lock, uuid: &#123;&#125;", uuid); retFlag = true; &#125; else &#123; log.info("Release lock, failed!"); &#125; multi.close();&#125; 当redis有多个节点时，我们需要奇数个点来按照多数原则判断是否获得了锁。程序中通过一个redis中的不通DB来模拟的。有效时间内，节点数大于一半，就认为获得成功，否则失败 12345678if ((passNode.get() &gt;= nodes / 2 + 1) &amp;&amp; (end - start) &lt; keyExpire) &#123; log.info("Get RedLock uuid &#123;&#125;, pass node:&#123;&#125;", uuid, passNode.get()); return uuid;&#125; else &#123; log.info("Get RedLock failed"); releaseLock(lockName, uuid); return null;&#125; 总结无论什么怎样实现分布式锁，都需要考虑一下内容： 判断锁是否存在和设置锁值，两步需要原子性 考虑申请锁时，申请的超时时间和尝试次数，具备非阻塞特性 需要考虑锁的正常销毁方式，主动删除锁 需要考虑锁的异常销毁方式，例如有效时间或者回话断开删除 适当考虑重入特性 使用总结： mysql 利用数据库特性还是很方便的，性能有限 zookeeper实现应该是非常严谨的，但是性能一般 Redis虽然实现上还存在争议，但是性能很好 性能: 缓存 &gt; Zookeeper &gt; 数据库可靠性: Zookeeper &gt; 缓存 &gt; 数据库 实现复杂度，看你对谁熟悉了，我个人感觉得差不多。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>mysql</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper]]></title>
    <url>%2F2018%2F10%2F18%2Fzookeeper%2F</url>
    <content type="text"><![CDATA[近期在做MQ的实验，所以又接触了一下Zookeeper，之所说又是因为之前碰到过，但是只是用而已没有了解过一些细节。 Zookeeper 做什么？引用官方原话：ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. 他可以提供高可靠的分布式协调服务，包括中心化配置服务等。之前我用它做了什么，注册发现服务器，你是不是也是用了这个功能，但是具体怎么实现的，Spring Cloud都已经实现了，没有深入关心过。 这个文章我们补一些必要的知识，更加深入的了解Zookeeper。 Zookeeper 怎么玩？首先，简单说他好似一个文件目录，是一个可以存储数据的服务器，这里我们先忽略其集群中的一些特性（选举制度等），我们看它对外可以提供什么。 它内部有类似文件目录的结构，节点称之为znode 文件结构可以存储数据，可以想象为目录结构的Redis 节点数据大小有限，不可以超过1M 可以通过接口获得数据，这也是我们用其分布式协调服务的关键 补充，数据过大怎么办，目前了解到的有两个思路，没有实验过： 使用专业的分布式存储HDFS等 使用Redis，然后zookeeper记录索引就好了 命令行两种形式，分别对应查看管理 服务器状态和内部存储。 查看管理服务器状态，可以通过telnet 和 nc发出指令，一般使用nc比较方便（具体命令参考网上信息） 1234567891011echo stat| nc 127.0.0.1 2181 # 来查看哪个节点被选择作为follower或者leaderecho ruok| nc 127.0.0.1 2181 # 测试是否启动了该Server，若回复imok表示已经启动。echo dump| nc 127.0.0.1 2181 # 列出未经处理的会话和临时节点。echo kill | nc 127.0.0.1 2181 # 关掉serverecho conf | nc 127.0.0.1 2181 # 输出相关服务配置的详细信息。echo cons | nc 127.0.0.1 2181 # 列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息。echo envi | nc 127.0.0.1 2181 # 输出关于服务环境的详细信息（区别于 conf 命令）。echo reqs | nc 127.0.0.1 2181 # 列出未经处理的请求。echo wchs | nc 127.0.0.1 2181 # 列出服务器 watch 的详细信息。echo wchc | nc 127.0.0.1 2181 # 通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表。echo wchp | nc 127.0.0.1 2181 # 通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径。 如果提示：xxx is not executed because it is not in the whitelist.请在conf/zoo.cfg中添加： 14lw.commands.whitelist=* #或者具体指令stat, ruok 查看管理服务中的节点信息，需要zkCli命令（客户端），这个在zookeeper所对应的bin目录下有，zkCli进入后，随便敲点啥，你可以看到如下： 1234567891011121314151617181920212223242526272829[zk: localhost:2181(CONNECTED) 0] ?ZooKeeper -server host:port cmd args addauth scheme auth close config [-c] [-w] [-s] connect host:port create [-s] [-e] [-c] [-t ttl] path [data] [acl] delete [-v version] path deleteall path delquota [-n|-b] path get [-s] [-w] path getAcl [-s] path history listquota path ls [-s] [-w] [-R] path ls2 path [watch] printwatches on|off quit reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*] redo cmdno removewatches path [-c|-d|-a] [-l] rmr path set [-s] [-v version] path data setAcl [-s] [-v version] path acl setquota -n|-b val path stat [-w] path sync pathCommand not found: Command not found ?[zk: localhost:2181(CONNECTED) 1] 我主要使用了： ls 显示znode crate 创建znode，并设置初始内容 get 获取znode内容 set 修改znode内容 delete 删除znode 退出客户端： quit 实验工程测试工程地址 ，开发环境： mac os x &amp; idea &amp; gradle spring cloud &amp; zookeeper config &amp; discovery zookeeper 3.5 in docker 请注意，其中使用的最新版的curator包只支持zookeeper3.5 关键代码通过CuratorFramework 设置或读取zookeeper中的节点 123456789curatorFramework.blockUntilConnected();Stat stat = curatorFramework.checkExists().forPath("/test");if(stat==null) &#123; curatorFramework.create().creatingParentsIfNeeded() .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE) .forPath("/test", "data".getBytes());&#125;byte[] bytes = curatorFramework.getData().forPath("/test");log.info("path test:&#123;&#125;", new String(bytes)); 将zookeeper作为配置中心，通过value注解获取zookeeper中的配置信息，这样可以做到在不重新启动服务的情况下，动态加载配置信息代码需要： 12@Value("$&#123;zc&#125;")private String zc; 也可以将配置信息加载到一个对象上，并实现动态刷新 123456789@Component@RefreshScope@ConfigurationProperties("demopro")public class DemoProperties &#123; private String key; private String value; //get set&#125; 配置文件需要： 12345678application: name: zookeeperDemo config: enabled: true root: /demo defaultContext: context profileSeparator: ',' 因为spring cloud支持active profile，所以对应的zookeeper的znode路径可以是： /demo/zookeeperDemo,default /demo/zookeeperDemo /demo/context,default /demo/context 具体到zc这个配置，对应在default下的全路径是：/demo/zookeeperDemo,default/zc，你可以在zookeeper中创建一个： 1create /demo/zookeeperDemo,default/zc data 具体到DemoProperties配置对应在default下的全路径是： 12create /demo/zookeeperDemo,default/demopro.key prokeycreate /demo/zookeeperDemo,default/demopro.value provalue 以上为工程实验的关键点，具体工程参考源码，工程后续可能还会更新。 吐槽这些问题不是针对zookeeper，只是借此表达一下，其它国内实例代码也有类似的普遍现象 Curator的使用，国内几乎没有，说明大家几乎没有尝试自己去使用zookeeper的存储功能，都是人云亦云般的介绍功能 查看中心化配置，路径的写法几乎都没有验证，实例代码几乎都不起作用，你们贴别人代码时不实验一下吗？ 请大家（同行）做到，我写的，我贴的，我抄的代码，我至少都实验过，不要传播错误的代码。共勉！]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Message Queue 初探]]></title>
    <url>%2F2018%2F10%2F16%2Fmq%2F</url>
    <content type="text"><![CDATA[消息队列（MQ），平时经常遇到的中间件技术。个人工作中已经使用的RabbitMQ，最近开始使用Kafka，因此也打算把ActiveMQ实验一下。所以本文章将围绕这三个MQ产品进行相应的实验。 创建实验工程三个MQ实验工程地址 工程使用spring boot创建，所有实现都将基于spring全家桶，已经很完毕了，拿来直接用吧。 为了后续实验方便，分别多个mq的producer和consumer工程 使用gradle管理项目结构 使用docker搭建测试所需要的服务器，文件可以参考，实际部署环境有所调整 Kafka首先实验了Kafka的生产和消费基本代码procuder： 1this.kafkaTemplate.send(topic, message); consumer: 1@KafkaListener(topics = "$&#123;app.topic&#125;") 运行说明 使用三个kafka broker 节点，使用docker-compose对应的service实现![](/images/post/20181016/kafka brokers.png) 创建topic，使用三个分区和两个副本![](/images/post/20181016/kafka topic.png) 使用idea，运行工程，配置多个运行实例![](/images/post/20181016/kafka run dashboard.png) 特性总结 一个分区对应一个消费者 一个分区内消息顺序消费 分区和和服务器应该成倍数关系，保证分区均匀分布 副本数量应该小于服务器数量，当可用分区失效时，从副本中选出leader，成为新的可用分区 节点高可用性，消费服务瞬间切换 保存近期所有数据，通过offset可以获得任意位置的消息 是否允许自动创建topic需要在kafka中配置 ACK MODE 和 Commit需要注意ack mode和 commit，此项影响数据的刷盘机制。根据实际情况选择 RECORD 逐笔ack并提交 BATCH 一个poll周期进行ack提交 TIME 通过设置ackTime定时提交 COUNT 通过设置ackCount累计数量提交 COUNT_TIME 同上组合，哪个复合执行哪个 MANUAL 手动方式生成ack，批量提交 MANUAL_IMMEDIATE 手动方式生成ack并立即提交 广播与点对点广播有时也叫pub和sub，就是一个topic，多个订阅者。每个订阅者都会收到相同的消息，消息被多次消费。点对点，一个topic中的消息对应一个消费者，消息只会被消费一次 在Kafka的系统中，如何区分以上两种方式，是通过consumer group实现的。 多个消费者在一个consumer group中，那么他们就是一个消费整体，消息只会被一个具体的消费者消费一次如果想多个同时消费，那么需要多个consumer group。这样来看consumer group需要与具体服务对应，一般一个独立的服务需要消费一次消息。 总的来说，体会到了大家喜欢的它原因，具体一些实验后续将深入。建议参考阅读 ActiveMQ每个MQ中的术语大同小异，但又十分不统一，随着遵循的协议不一样，让我们看看ActiveMQ，它使用JMS协议 Queue 和 TopicTopicsIn JMS a Topic implements publish and subscribe semantics. When you publish a message it goes to all the subscribers who are interested - so zero to many subscribers will receive a copy of the message. Only subscribers who had an active subscription at the time the broker receives the message will get a copy of the message.![](/images/post/20181016/jms topic.png) QueuesA JMS Queue implements load balancer semantics. A single message will be received by exactly one consumer. If there are no consumers available at the time the message is sent it will be kept until a consumer is available that can process the message. If a consumer receives a message and does not acknowledge it before closing then the message will be redelivered to another consumer. A queue can have many consumers with messages load balanced across the available consumers.![](/images/post/20181016/jms queue.png) 这里的 topics 类似kafka中的广播，pub/sub 模式，queue是队列是点对点模式。他的主要区别是，消费方式的确定不是在consumer设置，而是在MQ Server中设置消费性质上同上： topic的消息会多个消费者同时消费，但并不做消息堆积，没有之前的消息 queue消息只有一个消费者消费，并做消息缓存堆积，直到消费为止 同时queue的消费者是负责均衡的会分摊消息队列的中的数据，但是不能保证按顺序执行![](/images/post/20181016/activemq consumer.png) 关键代码消费端 1234567891011121314151617@Beanpublic JmsListenerContainerFactory&lt;?&gt; queueListenerFactory(ConnectionFactory connectionFactory, DefaultJmsListenerContainerFactoryConfigurer configurer) &#123; DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); configurer.configure(factory, connectionFactory); return factory;&#125;@Beanpublic JmsListenerContainerFactory&lt;?&gt; topicListenerFactory(ConnectionFactory connectionFactory, DefaultJmsListenerContainerFactoryConfigurer configurer) &#123; DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); configurer.configure(factory, connectionFactory); factory.setPubSubDomain(true); return factory;&#125; 通过spring boot 配置文件可以指明消费方式，是topic还是queue，但是只能只一种。为了同时支持两种方式，我么需要声明JmsListenerContainerFactory。是否开启pub sub domain，决定是queue还是topic 1factory.setPubSubDomain(true); 同时配合JmsListener注解，就可以指明消费方式了。如果指明的消费方式与ActiveMQ所创建的queue或topic不一致，则消息不能正常消费。 1@JmsListener(destination = "$&#123;app.queue&#125;", containerFactory = "queueListenerFactory") 生产端 123456789@Bean public Queue queue() &#123; return new ActiveMQQueue(queueName); &#125; @Bean public Topic topic() &#123; return new ActiveMQTopic(topicName); &#125; 通过不通类型指明是topic还是queue 运行说明同样创建多个运行实例，来观察消费情况![](/images/post/20181016/activemq run dashboard.png) 观察ActiveMQ管理后台，你可以看到相关的配置信息![](/images/post/20181016/activemq queue.png)![](/images/post/20181016/activemq topic.png) 特性总结 简单，两种消费模式非常清晰，没有复杂的系统结构 自带管理后台还算好用 还需要深入体会其一些参数设置，初步感觉中规中矩没有什么好说的。😜 RabbitMQ最后说熟悉的RabbitMQ吧。我很喜欢RabbitMQ，功能上丰富，性能不错，相比ActiveMQ，我更喜欢RabbitMQ吧。当然具体使用，还是要分应用场景。 基本概念RabbitMQ中有几个主要概念，和其它MQ的定义有些区别，其为AMQP协议 Exchange 交换机，用于消息的分发，如果不指定则会使用默认的 Queue 队列，实际缓存数据的消息队列，可对应多个消费者 Topic 主题，消息可以有主题，用于exchange分配消息是的判断依据 virtual host 虚拟路径，可以创建虚拟路径将相关配置分开并设定特定用户用于访问控制 ![](/images/post/20181016/exchanges topic fanout direct.png) 消费方式RabiitMQ的消费方式和灵活度上应该是这三者中最好的，并且官方给出了详细的实例说明，超有爱❤️当然由于模式多，它也就是最复杂的。官方给出的六个实例，这里简单说一下，具体代码看原址 Hello World 最普通的生产消费代码 Work Queue 默认exchange，工作队列，一个队列被多个消费者消费，且一个消息只消费一次 Publish/Subscribe 发布订阅，通过exchange Fanout模式进行队列分发，实现一条消息可以被多个消费者消费 Routing 路由方式，通过exchange和routing key指定消息路由到具体的队列别特定的消费者消费 Topics 主题方式，通过exchange和topic比配规则指定消息路由到具体的队列别特定的消费者消费 RPC 通过消息队列实现RPC调用过程 Exchange 方式： direct exchange 直接点对点 fanout exchange 全体广播 topic exchange 主题广播 headers exchange 还没有用过 system exchange 还没有用过 关键代码生产端 123456789101112131415// 声明queue@Beanpublic Queue queue() &#123; return new Queue(queueName);&#125;// 声明fanout exchange@Beanpublic FanoutExchange exchange() &#123; return new FanoutExchange(broadcast, false, true);&#125;// 声明 queue与exchange的绑定关系@BeanBinding binding1(Queue queueBroadone, FanoutExchange exchange) &#123; return BindingBuilder.bind(queueBroadone).to(exchange);&#125; 消费端 1234@RabbitListener(queues = "$&#123;app.broadone&#125;")public void recevieOne(String message) &#123; log.info("consumer receive broadcast one: &#123;&#125;", message);&#125; 运行说明这里我只做消息在多消费者下顺序消费观察和广播观察，其它实例参考官网代码吧，没有必要重复了。 一个生产者、一个queue、多个消费者，和ActiveMQ queue方式，观察效果一致： 多个消费者的消息分摊，如果每条消费执行时间差异较大，消费顺序不保证一致![](/images/post/20181016/rabbitmq consumer.png) 消费退出，另一个消费者会接替未完成的消息工作 广播消息默认堆积，其本质还是消费队列，不能多个消费者消费一个queue实现pub/sub 同样创建多个运行实例，来观察消费情况![](/images/post/20181016/rabbitmq run dashboard.png) 管理后台可以看到的信息![](/images/post/20181016/rabbitmq queue.png)![](/images/post/20181016/rabbitmq exchange.png) 特性总结 功能多，使用灵活 AMQP，性能不错 管理后台方便 实验总结 如果你需要消息顺序消费、分布式存储的高可用性，指定消息位置再次消费，较高的吞吐 —— Kafka 如果你要消息正常消费，无顺序要求、无特殊路由要求。广播消费时，多个消费者可以监听一个queue的方式完成 —— ActiveMQ 如果你要适合多种消息根据自定义规则（通配符等）路由道不同的消息队列，或兼容不通场景，希望广播消息有堆积不丢失 —— RabbitMQ 以上MQ都还有很多配置参数应对不通的应用需求，可能通过配置实现默认不支持的功能，具体使用情况，如果以后遇到我再单独说明。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>MQ</tag>
        <tag>middleware</tag>
        <tag>Kafka</tag>
        <tag>ActiveMQ</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenStack 从入门到继续]]></title>
    <url>%2F2018%2F10%2F11%2Fopenstack%2F</url>
    <content type="text"><![CDATA[近期给自己挖的技术坑有点多，我忍不住再挖一个，最近又了解到了云服务的相关技术（算是技术储备吧） What is OpenStack?OpenStack是被广泛使用的云操作系统，它管啥，如图： Components所有组件详见：网站列出的所有组件 找几个介绍多的，简单说一下 HORIZON前端Web管理界面，包括Dashboard控件展示，便于用户对相关服务进行操作 NOVA计算服务,应该是管理计算资源的组件，提供相应的管理服务 NEUTRON提供云计算的网络虚拟化技术，为OpenStack其他服务提供网络连接服务，实现SDN SWIFTSwift是高可用、分布式、最终一致性的对象存储，具体文件对象 CINDER块存储服务，更像是硬盘，数据卷 KEYSTONE认证服务，支持LDAP Oauth OpenID等 GLANCE镜像服务，不通的操作系统镜像 HEAT编排架构资源 不通场景中需要不通的服务来构建，可以参考sample configurations What is the relationship between Docker and OpenStack![](/images/post/20181011/docker openstack.png) Docker 主要针对 Paas 平台，是以应用为中心。 OpenStack 主要针对 Iaas 平台，以资源为中心，可以为上层的 PaaS 平台提供存储、网络、计算等资源。 这个话题先开个头，后面有机会再继续深入吧。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>openstack</tag>
        <tag>cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的OKR(2018.10)]]></title>
    <url>%2F2018%2F09%2F29%2Fokr%2F</url>
    <content type="text"><![CDATA[最近重温吴军老师的硅谷来信，想起了Google人员采用的目标管理方法OKR(Objectives and Key Results)全称为“目标和关键成果”。吴军老师在其硅谷来信114封信中分享了这个方法（不仅可以用于工作也可以用于自己的生活）并结合他个人的2017年目标做了阐述。这也使我产生了同样念头，用OKR方式管理我自己的目标。 初衷和理解我希望我可以不断进步，可以用更为有效方式使自己获得成长，而对OKR目标管理初步了解下来，我认为是合适我的想法。 OKR的目标制定一般是需要一些挑战性的，这样才能达到自我提升的目的，我也将逐步加大目标达成的难度，同时开始也可能会有些设定不合理。 其次，目标不能太多，否则难以集中注意力，一般在5个以内。 时间不易太长或太短，太短难以实现有挑战性的目标。太长过程有可能有太多不确定性的事情打破原有的计划，使得制定意义减弱。所以借鉴Google的做法，制定季度OKR。 季度 OKR正好九月底了，10月开始正好是2018年最后一个季度，也将是我的第一个OKR季度。 目标一 英语流利说学习达标近期参加了英语流利说付费课程，提升自己的口语能力，也是近期主要的学习内容。 连续打卡，每天学习时间平均不低于70分钟 所有课程分数不低于3颗星🌟（满星4颗） 流利说评定的口语等级上升一级。（按照当前进度应该可以做到） 除此之外，我还在得到APP上购买了《吴军的谷歌方法论》和《香帅的北大金融学课》这个学习也会保持，但这个基本没有什么挑战了。 目标二 深入一个计算机中的流行技术学习掌握并深入一个流行的计算机技术 深入了解和掌握 Kubernets 这是我最近最想掌握的一个技术。除此之外我还会不定期更新个人github中的一些小例子，来记录我零碎的技术总结。 目标三 看完一本非计算机类书我的书单已经列了很久、很多了，是需要花些时间看看书了 看完赫拉利的《今日简史》，看看都提出了什么问题 因为时间原因，这个目标可能最难完成。之前把赫拉利的《人类简史》看完了，《未来简史》看了一部分，看不下去了，再找时间吧。而《今日简史》中的当今问题使我比较感兴趣的，想读读，也算是把赫拉利的著作都看了看。题外话，近半年还看了两个小说《副本》和《头号玩家》这两个都有对应的影视作品，感兴趣的朋友可以看看，纯当消遣。 目标四 锻炼身体，保持身体健康天气转凉，终于可以锻炼身体了，天气热时真的是懒得动，极爱出汗的我更喜欢冬天。 每周用Keep（一个健身APP）不少于2次， 每周 跑步不小于3公里（我知道这个目标定低了一些，我需要先适应一下） 每日睡眠（包含午休）不少于7个小时。 这个估计难度也不小，我可以支配的时间太有限了，现在晚上睡眠平均小于6小时，很少运动，这是我精力有些疲倦，所以需要改变一下。 目标五 陪孩子Family is first，我一直提醒自己，孩子又是其中最关键的。 每日至少用半个小时与孩子做有效沟通，了解一天的情况或讨论一个小事情 平均每周用完整的3个小时陪孩子做些有意义或者有趣的事情，包含户外活动等。 五个目标，不多不少，希望可以在下面一个季度都可以做到。 年度 OKR索性再列几个年度的OKR吧，希望后面一年可以做到 目标一 付费课程学习 购买付费课程，全年不少于三门，并完成学习内容 目标二 读书 读非计算机类、非小说类书，全年不少于5本。 目标三 英语口语 完成流利说口语付费课程内容 按照流利说标准，达到Level 6级或以上 当然还有工作上的一些目标，这里就详述了。 列出这些和大家分享，同时也是督促自己，如果你也感兴趣，不妨试试。如有好的建议和想法欢迎留言，谢谢！ I wanna improve myself, better late than never. OKR参考文章]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 11]]></title>
    <url>%2F2018%2F09%2F27%2FJava-11%2F</url>
    <content type="text"><![CDATA[昨天得知Java 11发布。请允许我说：我的天啊，竟然Java 11了。 连Java 8还没有完全熟练使用的我，一时间有点恍惚。 近期，Java更新如此频繁，让人有点应接不暇，新的features层出不穷，而我们又真的学习使用了几个呢？ 反正我只用了一小部分吧。这里不列举Java 8之后各个版本中的features了，大家可以自行Google。 这里只想说：Java作为生命力极强的大型服务类开发语言，Oracle好像在给其注入新的活力，也在打破Java原有的墨守陈规。我们可以看出它的很多新特性是源于这个时代技术的发展，也有很多借鉴了其它语言的特性，在”提(da)升(po)”原有的语法结构方式给用户带来新的开发体验。这也是在满足新加入Java世界的开发者？ 不知Java老程序员如何感受，就我而言，我更喜欢不断更新，虽然最近更新确实有点频繁了。 当然除了语法特性的改变意外，还有很多底层结构的改进，当然这才是其核心。例如类库发展、模块化管理、安全特性与补丁、新的JVM GC、脚本化、黑匣子(JFR)等。 试试不？Java 9 和 10 简直就是一闪而过，印象中好像就一两个小版本号，而Java 11 不同了，它可是LTS。Oracle官方承诺对其会有持续的update更新。同时大家深爱的Java 8马上就要不更新了，所以这次真的可以尝试进行JDK企业级切换了。 个人感觉Java 每半年更新的方式，看来要止住其语言发展的颓势，重新崛起了。Java作为主要的开发语言还是值得大家技术投入的。小伙伴们跟上这波更新吧。后面我也希望多尝试JDK新的开发特性。 你的感觉呢？ 参考网站 infoq]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Restart]]></title>
    <url>%2F2018%2F09%2F26%2Fnote%2F</url>
    <content type="text"><![CDATA[尝试重新开始尝试重启这个blog，因为有越来越多的文字需要记录，也想分享，而在github上的README.md文件中写又显然不合适。所以重新启用这个工程开始整理自己的随笔。 同时，几个月前开始更新自己的github工程，主要围绕三个项目： Java Tech Java相关技术 Python Tech Python相关技术 CICD Tech CI/CD DEV/OPS相关技术 维护这三个工程主要目的在于： 帮助自己总结所学，时间长了很容已忘记 本人使用的技术绝大部分本来就是公开的，也希望今后可以帮到其他人。 所以在所有项目或者示例代码中，我尽可能说明详细，并给出我所引用的原地址而还是有很多思路上的内容需要记录下来，所以想在这里记录，此blog也将围绕我的技术领域展开。 为何重新开始作为计算机开发工程师，本人离吴军老师所定义的四级工程师水平（详见谷歌来信中的定义）还有不少差距，而我希望可以做到。唯一的方法是不断积累。这里的重新开始是给自己设定了一个目标，一个改变自己的目标，重新开始向新的目标前进。 祝所有工程师好运！]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
</search>
